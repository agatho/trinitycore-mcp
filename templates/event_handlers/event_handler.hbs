/**
 * {{className}} - {{description}}
 *
 * Auto-generated by TrinityCore MCP Server
 * Generation date: {{generationDate}}
 * Template: event_handler.hbs
 *
 * Event Type: {{eventType}}
 * Priority: {{priority}}
 */

#pragma once

#include "EventMgr.h"
#include "Player.h"
#include "Unit.h"
#include "Spell.h"

{{#if namespace}}
namespace {{namespace}} {
{{/if}}

/**
 * {{className}}
 * {{description}}
 *
 * Handles: {{eventType}} events
 * Priority: {{priority}}
 * Thread-safe: {{threadSafe}}
 */
class {{className}} : public EventHandler {
public:
    {{className}}();
    virtual ~{{className}}() = default;

    // EventHandler interface
    bool CanHandle(EventType type) const override;
    void HandleEvent(Event* event) override;

    // Event-specific handlers
{{#if handlesCombat}}
    void OnCombatStart(Player* player, Unit* target);
    void OnCombatEnd(Player* player);
    void OnDamageTaken(Player* player, Unit* attacker, uint32 damage);
    void OnDamageDealt(Player* player, Unit* victim, uint32 damage);
{{/if}}
{{#if handlesSpell}}
    void OnSpellCast(Player* player, Spell* spell);
    void OnSpellHit(Player* player, Unit* target, Spell* spell);
    void OnSpellMiss(Player* player, Unit* target, Spell* spell);
{{/if}}
{{#if handlesMovement}}
    void OnMovementStart(Player* player);
    void OnMovementStop(Player* player);
    void OnPositionChange(Player* player, Position const& pos);
{{/if}}
{{#if handlesTarget}}
    void OnTargetChange(Player* player, Unit* newTarget);
    void OnTargetDied(Player* player, Unit* target);
{{/if}}
{{#if handlesAura}}
    void OnAuraApply(Player* player, Aura* aura);
    void OnAuraRemove(Player* player, Aura* aura);
{{/if}}

private:
    // Helper methods
    bool IsValidEvent(Event* event) const;
    void LogEvent(Event* event) const;

{{#if includeMetrics}}
    // Metrics tracking
    void RecordEventHandled(EventType type);
    uint32 GetEventsHandled() const { return m_eventsHandled; }

    std::atomic<uint32> m_eventsHandled{0};
{{/if}}

{{#if includeThreadSafety}}
    // Thread safety
    mutable std::mutex m_mutex;
{{/if}}
};

{{#if namespace}}
} // namespace {{namespace}}
{{/if}}

/**
 * Implementation
 */

{{#if namespace}}
namespace {{namespace}} {
{{/if}}

{{className}}::{{className}}()
{
    // Initialize event handler
}

bool {{className}}::CanHandle(EventType type) const
{
    switch (type)
    {
{{#if handlesCombat}}
        case EVENT_COMBAT_START:
        case EVENT_COMBAT_END:
        case EVENT_DAMAGE_TAKEN:
        case EVENT_DAMAGE_DEALT:
{{/if}}
{{#if handlesSpell}}
        case EVENT_SPELL_CAST:
        case EVENT_SPELL_HIT:
        case EVENT_SPELL_MISS:
{{/if}}
{{#if handlesMovement}}
        case EVENT_MOVEMENT_START:
        case EVENT_MOVEMENT_STOP:
        case EVENT_POSITION_CHANGE:
{{/if}}
{{#if handlesTarget}}
        case EVENT_TARGET_CHANGE:
        case EVENT_TARGET_DIED:
{{/if}}
{{#if handlesAura}}
        case EVENT_AURA_APPLY:
        case EVENT_AURA_REMOVE:
{{/if}}
            return true;
        default:
            return false;
    }
}

void {{className}}::HandleEvent(Event* event)
{
    if (!IsValidEvent(event))
        return;

{{#if includeThreadSafety}}
    std::lock_guard<std::mutex> lock(m_mutex);
{{/if}}

    switch (event->GetType())
    {
{{#if handlesCombat}}
        case EVENT_COMBAT_START:
            OnCombatStart(event->GetPlayer(), event->GetUnit());
            break;
        case EVENT_COMBAT_END:
            OnCombatEnd(event->GetPlayer());
            break;
        case EVENT_DAMAGE_TAKEN:
            OnDamageTaken(event->GetPlayer(), event->GetUnit(), event->GetAmount());
            break;
        case EVENT_DAMAGE_DEALT:
            OnDamageDealt(event->GetPlayer(), event->GetUnit(), event->GetAmount());
            break;
{{/if}}
{{#if handlesSpell}}
        case EVENT_SPELL_CAST:
            OnSpellCast(event->GetPlayer(), event->GetSpell());
            break;
        case EVENT_SPELL_HIT:
            OnSpellHit(event->GetPlayer(), event->GetUnit(), event->GetSpell());
            break;
        case EVENT_SPELL_MISS:
            OnSpellMiss(event->GetPlayer(), event->GetUnit(), event->GetSpell());
            break;
{{/if}}
{{#if handlesMovement}}
        case EVENT_MOVEMENT_START:
            OnMovementStart(event->GetPlayer());
            break;
        case EVENT_MOVEMENT_STOP:
            OnMovementStop(event->GetPlayer());
            break;
        case EVENT_POSITION_CHANGE:
            OnPositionChange(event->GetPlayer(), event->GetPosition());
            break;
{{/if}}
{{#if handlesTarget}}
        case EVENT_TARGET_CHANGE:
            OnTargetChange(event->GetPlayer(), event->GetUnit());
            break;
        case EVENT_TARGET_DIED:
            OnTargetDied(event->GetPlayer(), event->GetUnit());
            break;
{{/if}}
{{#if handlesAura}}
        case EVENT_AURA_APPLY:
            OnAuraApply(event->GetPlayer(), event->GetAura());
            break;
        case EVENT_AURA_REMOVE:
            OnAuraRemove(event->GetPlayer(), event->GetAura());
            break;
{{/if}}
        default:
            break;
    }

{{#if includeMetrics}}
    RecordEventHandled(event->GetType());
{{/if}}
    LogEvent(event);
}

bool {{className}}::IsValidEvent(Event* event) const
{
    return event && event->GetPlayer() && CanHandle(event->GetType());
}

void {{className}}::LogEvent(Event* event) const
{
    // Log event for debugging
    // TC_LOG_DEBUG("bot.event", "{{className}}: Handled event %u for player %s",
    //     event->GetType(), event->GetPlayer()->GetName().c_str());
}

{{#if handlesCombat}}
void {{className}}::OnCombatStart(Player* player, Unit* target)
{
    // [Implement combat start logic]
}

void {{className}}::OnCombatEnd(Player* player)
{
    // [Implement combat end logic]
}

void {{className}}::OnDamageTaken(Player* player, Unit* attacker, uint32 damage)
{
    // [Implement damage taken logic]
}

void {{className}}::OnDamageDealt(Player* player, Unit* victim, uint32 damage)
{
    // [Implement damage dealt logic]
}
{{/if}}

{{#if handlesSpell}}
void {{className}}::OnSpellCast(Player* player, Spell* spell)
{
    // [Implement spell cast logic]
}

void {{className}}::OnSpellHit(Player* player, Unit* target, Spell* spell)
{
    // [Implement spell hit logic]
}

void {{className}}::OnSpellMiss(Player* player, Unit* target, Spell* spell)
{
    // [Implement spell miss logic]
}
{{/if}}

{{#if handlesMovement}}
void {{className}}::OnMovementStart(Player* player)
{
    // [Implement movement start logic]
}

void {{className}}::OnMovementStop(Player* player)
{
    // [Implement movement stop logic]
}

void {{className}}::OnPositionChange(Player* player, Position const& pos)
{
    // [Implement position change logic]
}
{{/if}}

{{#if handlesTarget}}
void {{className}}::OnTargetChange(Player* player, Unit* newTarget)
{
    // [Implement target change logic]
}

void {{className}}::OnTargetDied(Player* player, Unit* target)
{
    // [Implement target died logic]
}
{{/if}}

{{#if handlesAura}}
void {{className}}::OnAuraApply(Player* player, Aura* aura)
{
    // [Implement aura apply logic]
}

void {{className}}::OnAuraRemove(Player* player, Aura* aura)
{
    // [Implement aura remove logic]
}
{{/if}}

{{#if includeMetrics}}
void {{className}}::RecordEventHandled(EventType type)
{
    m_eventsHandled.fetch_add(1, std::memory_order_relaxed);
}
{{/if}}

{{#if namespace}}
} // namespace {{namespace}}
{{/if}}

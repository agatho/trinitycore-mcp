/**
 * {{className}} - {{description}}
 *
 * Auto-generated by TrinityCore MCP Server
 * Generation date: {{generationDate}}
 * Template: combat_strategy.hbs
 *
 * Thread-safety: {{threadSafety}}
 * Performance target: {{performanceTarget}}
 */

#pragma once

#include "AI/BotAI.h"
#include "AI/Strategies/CombatStrategy.h"
#include "Entities/Unit/Unit.h"
#include "Packets/SpellPacketBuilder.h"

{{#if includeThreadSafety}}
#include <atomic>
#include <mutex>
{{/if}}

{{#if namespace}}
namespace {{namespace}} {
{{/if}}

/**
 * {{className}}
 * {{description}}
 *
 * Role: {{role}}
 * Engagement Range: {{engagementRange}}m
 * Update Frequency: {{updateFrequency}}ms
 */
class {{className}} : public {{baseClass}} {
public:
    {{className}}();
    virtual ~{{className}}() = default;

    // Core strategy interface
    void Update(BotAI* ai, uint32 diff) override;
    bool ShouldEngage(Unit* target) const override;
    float GetEngagementRange() const override { return {{engagementRange}}f; }

    // Target selection
    Unit* SelectTarget(BotAI* ai) const override;
    bool IsValidTarget(Unit* target) const override;

    // Ability management
    uint32 GetNextAbility(BotAI* ai) const override;
    bool ShouldUseDefensiveCooldown(BotAI* ai) const override;
    bool ShouldUseOffensiveCooldown(BotAI* ai) const override;

    // Role-specific methods
{{#if isHealer}}
    Unit* SelectHealTarget(BotAI* ai) const;
    bool NeedEmergencyHeal(Unit* target) const;
    uint32 GetHealSpell(Unit* target) const;
{{/if}}
{{#if isTank}}
    void ManageThreat(BotAI* ai, Unit* target) const;
    bool NeedThreatBoost(BotAI* ai) const;
    uint32 GetThreatSpell() const;
{{/if}}
{{#if isDPS}}
    uint32 GetRotationSpell(BotAI* ai) const;
    bool ShouldUseCooldown(BotAI* ai) const;
    float CalculateDPS(BotAI* ai) const;
{{/if}}

private:
    // Helper methods
    bool HasEnoughMana(Player* bot, uint32 spellId) const;
    bool IsSpellReady(Player* bot, uint32 spellId) const;
    float CalculateThreat(Unit* target) const;

    // Priority calculation
    struct AbilityPriority {
        uint32 spellId;
        float priority;
        std::function<bool(BotAI*)> condition;
    };

    std::vector<AbilityPriority> BuildRotation(BotAI* ai) const;

{{#if includeThreadSafety}}
    // Thread safety
    mutable std::mutex m_mutex;
    std::atomic<uint32> m_lastUpdate{0};
{{/if}}

    // Configuration
    static constexpr float ENGAGEMENT_RANGE = {{engagementRange}}f;
    static constexpr uint32 UPDATE_INTERVAL = {{updateFrequency}};

    // Spell IDs
    enum Spells {
{{#each spellIds}}
        {{@key}} = {{this}},
{{/each}}
    };
};

{{#if namespace}}
} // namespace {{namespace}}
{{/if}}

// Implementation
{{#if namespace}}
namespace {{namespace}} {
{{/if}}

{{className}}::{{className}}() {
    // Initialize strategy
}

void {{className}}::Update(BotAI* ai, uint32 diff) {
{{#if includeThreadSafety}}
    std::lock_guard<std::mutex> lock(m_mutex);
    m_lastUpdate = WorldGameTime::GetGameTime();
{{/if}}

    Player* bot = ai->GetBot();
    if (!bot || !bot->IsInCombat())
        return;

    // Get current target
    Unit* target = ai->GetCurrentTarget();
    if (!target || !IsValidTarget(target)) {
        target = SelectTarget(ai);
        if (target)
            ai->SetCurrentTarget(target);
    }

    if (!target)
        return;

{{#if isHealer}}
    // Healer logic: prioritize healing over damage
    Unit* healTarget = SelectHealTarget(ai);
    if (healTarget && NeedEmergencyHeal(healTarget)) {
        uint32 healSpell = GetHealSpell(healTarget);
        if (healSpell && IsSpellReady(bot, healSpell)) {
            SpellPacketBuilder builder;
            builder.CastSpell(bot, healSpell, healTarget);
            return;
        }
    }
{{/if}}

{{#if isTank}}
    // Tank logic: manage threat
    ManageThreat(ai, target);

    if (NeedThreatBoost(ai)) {
        uint32 threatSpell = GetThreatSpell();
        if (threatSpell && IsSpellReady(bot, threatSpell)) {
            SpellPacketBuilder builder;
            builder.CastSpell(bot, threatSpell, target);
        }
    }
{{/if}}

{{#if isDPS}}
    // DPS logic: execute rotation
    uint32 rotationSpell = GetRotationSpell(ai);
    if (rotationSpell && IsSpellReady(bot, rotationSpell)) {
        SpellPacketBuilder builder;
        builder.CastSpell(bot, rotationSpell, target);
    }

    // Check for cooldown usage
    if (ShouldUseCooldown(ai)) {
        ShouldUseOffensiveCooldown(ai);
    }
{{/if}}

    // Execute combat rotation
    uint32 abilityId = GetNextAbility(ai);
    if (abilityId && IsSpellReady(bot, abilityId)) {
        SpellPacketBuilder builder;
        builder.CastSpell(bot, abilityId, target);
    }

    // Check for defensive cooldowns
    if (ShouldUseDefensiveCooldown(ai)) {
        // Use defensive abilities if health < {{defensiveThreshold}}%
        if (bot->HealthBelowPct({{defensiveThreshold}})) {
            // Implement defensive cooldown logic
        }
    }
}

bool {{className}}::ShouldEngage(Unit* target) const {
    if (!target || target->IsDead())
        return false;

{{#if isTank}}
    // Tanks engage aggressively
    return target->IsHostileTo(ai->GetBot()) &&
           target->IsWithinDistInMap(ai->GetBot(), ENGAGEMENT_RANGE);
{{else if isHealer}}
    // Healers engage conservatively
    return false; // Focus on healing
{{else}}
    // DPS engage if target is in range
    return target->IsHostileTo(ai->GetBot()) &&
           target->IsWithinDistInMap(ai->GetBot(), ENGAGEMENT_RANGE);
{{/if}}
}

Unit* {{className}}::SelectTarget(BotAI* ai) const {
    Player* bot = ai->GetBot();

    // Prioritize current target
    if (Unit* current = ai->GetCurrentTarget())
        if (IsValidTarget(current))
            return current;

{{#if isTank}}
    // Tanks prioritize highest threat target
    Unit* highestThreat = nullptr;
    float maxThreat = 0.0f;

    std::list<Unit*> targets;
    Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(bot, ENGAGEMENT_RANGE);
    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, check);
    Cell::VisitAllObjects(bot, searcher, ENGAGEMENT_RANGE);

    for (Unit* target : targets) {
        if (!IsValidTarget(target))
            continue;

        float threat = CalculateThreat(target);
        if (threat > maxThreat) {
            maxThreat = threat;
            highestThreat = target;
        }
    }

    return highestThreat;
{{else}}
    // Find nearest hostile target
    Unit* nearestTarget = nullptr;
    float nearestDist = 999999.0f;

    std::list<Unit*> targets;
    Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(bot, ENGAGEMENT_RANGE);
    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, check);
    Cell::VisitAllObjects(bot, searcher, ENGAGEMENT_RANGE);

    for (Unit* target : targets) {
        if (!IsValidTarget(target))
            continue;

        float dist = bot->GetDistance(target);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestTarget = target;
        }
    }

    return nearestTarget;
{{/if}}
}

bool {{className}}::IsValidTarget(Unit* target) const {
    return target &&
           !target->IsDead() &&
           target->IsInWorld() &&
           target->IsHostileTo(ai->GetBot());
}

uint32 {{className}}::GetNextAbility(BotAI* ai) const {
    Player* bot = ai->GetBot();
    Unit* target = ai->GetCurrentTarget();

    if (!bot || !target)
        return 0;

    // Build priority rotation
    std::vector<AbilityPriority> rotation = BuildRotation(ai);

    // Sort by priority (highest first)
    std::sort(rotation.begin(), rotation.end(),
        [](const AbilityPriority& a, const AbilityPriority& b) {
            return a.priority > b.priority;
        });

    // Execute highest priority available ability
    for (const auto& ability : rotation) {
        if (ability.condition(ai) && IsSpellReady(bot, ability.spellId)) {
            return ability.spellId;
        }
    }

    return 0;
}

std::vector<{{className}}::AbilityPriority> {{className}}::BuildRotation(BotAI* ai) const {
    std::vector<AbilityPriority> rotation;

{{#each rotation}}
    // {{this.description}}
    rotation.push_back({
        {{this.spellId}},
        {{this.priority}},
        [](BotAI* ai) -> bool {
            {{this.condition}}
        }
    });
{{/each}}

    return rotation;
}

bool {{className}}::ShouldUseDefensiveCooldown(BotAI* ai) const {
    Player* bot = ai->GetBot();
    return bot->HealthBelowPct({{defensiveThreshold}});
}

bool {{className}}::ShouldUseOffensiveCooldown(BotAI* ai) const {
    Unit* target = ai->GetCurrentTarget();
    if (!target)
        return false;

{{#if isTank}}
    // Tanks use offensive cooldowns for threat
    return NeedThreatBoost(ai);
{{else if isDPS}}
    // DPS use cooldowns on bosses or when target > 80% health
    return target->GetHealthPct() > 80.0f || target->IsWorldBoss();
{{else}}
    return false;
{{/if}}
}

// Helper method implementations
bool {{className}}::HasEnoughMana(Player* bot, uint32 spellId) const {
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    return bot->GetPower(POWER_MANA) >= spellInfo->CalcPowerCost(bot, spellInfo->GetSchoolMask());
}

bool {{className}}::IsSpellReady(Player* bot, uint32 spellId) const {
    return bot->HasSpell(spellId) &&
           !bot->HasSpellCooldown(spellId) &&
           HasEnoughMana(bot, spellId);
}

float {{className}}::CalculateThreat(Unit* target) const {
    // Simplified threat calculation
    return target->GetThreat(ai->GetBot());
}

{{#if isHealer}}
Unit* {{className}}::SelectHealTarget(BotAI* ai) const {
    Player* bot = ai->GetBot();
    Unit* lowestHealth = nullptr;
    float lowestPct = 100.0f;

    // Check self first
    if (bot->HealthBelowPct(70)) {
        return bot;
    }

    // Check group members
    Group* group = bot->GetGroup();
    if (group) {
        for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next()) {
            Player* member = ref->GetSource();
            if (!member || !member->IsInWorld())
                continue;

            float healthPct = member->GetHealthPct();
            if (healthPct < lowestPct && member->IsWithinDistInMap(bot, 40.0f)) {
                lowestPct = healthPct;
                lowestHealth = member;
            }
        }
    }

    return lowestHealth;
}

bool {{className}}::NeedEmergencyHeal(Unit* target) const {
    return target && target->HealthBelowPct(30);
}

uint32 {{className}}::GetHealSpell(Unit* target) const {
    if (!target)
        return 0;

    if (NeedEmergencyHeal(target)) {
        // Use fast emergency heal
        return Spells::EMERGENCY_HEAL;
    } else if (target->HealthBelowPct(70)) {
        // Use efficient heal
        return Spells::EFFICIENT_HEAL;
    }

    return 0;
}
{{/if}}

{{#if isTank}}
void {{className}}::ManageThreat(BotAI* ai, Unit* target) const {
    // Implement tank-specific threat management
    if (NeedThreatBoost(ai)) {
        uint32 threatSpell = GetThreatSpell();
        // Threat spell will be cast in Update()
    }
}

bool {{className}}::NeedThreatBoost(BotAI* ai) const {
    Unit* target = ai->GetCurrentTarget();
    if (!target)
        return false;

    // Check if we're losing threat
    float ourThreat = target->GetThreat(ai->GetBot());
    float maxThreat = 0.0f;

    // Find highest threat from other targets
    for (auto& threatRef : target->GetThreatManager().GetThreatList()) {
        if (threatRef->GetVictim() != ai->GetBot()) {
            maxThreat = std::max(maxThreat, threatRef->GetThreat());
        }
    }

    // Need threat boost if someone else has 90%+ of our threat
    return maxThreat > (ourThreat * 0.9f);
}

uint32 {{className}}::GetThreatSpell() const {
    return Spells::THREAT_GENERATOR;
}
{{/if}}

{{#if isDPS}}
uint32 {{className}}::GetRotationSpell(BotAI* ai) const {
    // Delegate to GetNextAbility for DPS rotation
    return GetNextAbility(ai);
}

bool {{className}}::ShouldUseCooldown(BotAI* ai) const {
    return ShouldUseOffensiveCooldown(ai);
}

float {{className}}::CalculateDPS(BotAI* ai) const {
    // Simplified DPS calculation
    Player* bot = ai->GetBot();
    if (!bot)
        return 0.0f;

    // Estimate based on attack power and spell power
    float ap = bot->GetTotalAttackPowerValue(BASE_ATTACK);
    float sp = bot->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL);

    return (ap + sp) / 10.0f; // Simplified estimation
}
{{/if}}

{{#if namespace}}
} // namespace {{namespace}}
{{/if}}

/**
 * Spell data query tool
 * Week 7: Enhanced with Spell.db2 integration via DB2CachedFileLoader
 */

import { queryWorld } from "../database/connection.js";
import { DB2CachedLoaderFactory } from "../parsers/db2/DB2CachedFileLoader.js";
import { SchemaFactory } from "../parsers/schemas/SchemaFactory.js";
import * as path from "path";
import * as fs from "fs";
import {
  getSpellRange as getSpellRangeData,
  getSpellRangeDescription,
  isMeleeRange,
  isUnlimitedRange,
  getMaxEffectiveRange,
  type SpellRangeEntry
} from "../data/spell-ranges.js";

export interface SpellInfo {
  spellId: number;
  name: string;
  rank?: string;
  description?: string;
  tooltip?: string;
  category: number;
  dispel: number;
  mechanic: number;
  attributes: string[];
  castTime: number;
  cooldown: number;
  duration: number;
  powerCost: number;
  powerType: string;
  range: {
    min: number;
    max: number;
  };
  speed: number;
  effects: SpellEffect[];
  // Week 7: Enhanced with DB2 data
  db2Data?: {
    spellName?: string;
    rank?: string;
    description?: string;
    spellIconFileDataID?: number;
    activeIconFileDataID?: number;
  };
  dataSource: "database" | "db2" | "merged";
  cacheStats?: {
    db2CacheHit: boolean;
    loadTime?: string;
  };
  error?: string;
}

export interface SpellEffect {
  index: number;
  effect: number;
  effectName: string;
  basePoints: number;
  radiusIndex: number;
  aura: number;
  auraName?: string;
  implicitTargetA: number;
  implicitTargetB: number;
}

// DB2 file paths
const DB2_PATH = process.env.DB2_PATH || "./data/db2";
const SPELL_DB2_FILE = "Spell.db2";

/**
 * Load spell data from Spell.db2 via cached loader
 * @param spellId Spell ID to query
 * @returns Parsed SpellEntry or null if not found
 */
async function loadSpellFromDB2(spellId: number): Promise<{
  data: any | null;
  cacheHit: boolean;
  loadTime: number;
}> {
  const startTime = Date.now();

  try {
    const filePath = path.join(DB2_PATH, SPELL_DB2_FILE);

    // Check if file exists
    if (!fs.existsSync(filePath)) {
      return { data: null, cacheHit: false, loadTime: Date.now() - startTime };
    }

    // Get cached loader (singleton per file)
    const loader = DB2CachedLoaderFactory.getLoader(SPELL_DB2_FILE);

    // Load file if not already loaded
    try {
      if (loader.getRecordCount() === 0) {
        loader.loadFromFile(filePath);
      }
    } catch (loadError) {
      loader.loadFromFile(filePath);
    }

    // Get cache stats before access
    const statsBefore = loader.getCacheStats();
    const hitsBefore = statsBefore.totalHits;

    // Try to get typed record (automatically cached)
    const spellEntry = loader.getTypedRecord<any>(spellId);

    // Check if this was a cache hit
    const statsAfter = loader.getCacheStats();
    const cacheHit = statsAfter.totalHits > hitsBefore;

    return {
      data: spellEntry,
      cacheHit,
      loadTime: Date.now() - startTime,
    };
  } catch (error) {
    console.error("Error loading spell from DB2:", error);
    return { data: null, cacheHit: false, loadTime: Date.now() - startTime };
  }
}

/**
 * Get detailed spell information from world database and Spell.db2
 * Week 7: Enhanced to merge database + DB2 data with caching
 */
export async function getSpellInfo(spellId: number): Promise<SpellInfo> {
  try {
    // Step 1: Load from DB2 (with caching)
    const db2Result = await loadSpellFromDB2(spellId);
    const db2Spell = db2Result.data;

    // Step 2: Query spell_template for database data
    const spellQuery = `
      SELECT
        ID as spellId,
        SpellName as name,
        Rank as rank,
        Description as description,
        AuraDescription as tooltip,
        Category as category,
        Dispel as dispel,
        Mechanic as mechanic,
        CastTimeIndex as castTime,
        RecoveryTime as cooldown,
        DurationIndex as duration,
        ManaCost as powerCost,
        PowerType as powerType,
        Speed as speed,
        RangeIndex as rangeIndex
      FROM spell_template
      WHERE ID = ?
      LIMIT 1
    `;

    const spells = await queryWorld(spellQuery, [spellId]);
    const dbSpell = spells && spells.length > 0 ? spells[0] : null;

    // Step 3: Determine data source
    let dataSource: "database" | "db2" | "merged" = "database";
    if (db2Spell && dbSpell) {
      dataSource = "merged";
    } else if (db2Spell && !dbSpell) {
      dataSource = "db2";
    } else if (!db2Spell && !dbSpell) {
      // Neither source has data
      return {
        spellId,
        name: "Not Found",
        category: 0,
        dispel: 0,
        mechanic: 0,
        attributes: [],
        castTime: 0,
        cooldown: 0,
        duration: 0,
        powerCost: 0,
        powerType: "MANA",
        range: { min: 0, max: 0 },
        speed: 0,
        effects: [],
        dataSource: "database",
        cacheStats: {
          db2CacheHit: db2Result.cacheHit,
          loadTime: `${db2Result.loadTime}ms`,
        },
        error: `Spell ${spellId} not found in database or DB2`,
      };
    }

    // Step 4: Merge data (prefer database for gameplay values, DB2 for names/descriptions)
    const spell = dbSpell || {};

    // Query spell effects
    const effectsQuery = `
      SELECT
        EffectIndex as effectIndex,
        Effect as effect,
        EffectBasePoints as basePoints,
        EffectRadiusIndex as radiusIndex,
        EffectApplyAuraName as aura,
        EffectImplicitTargetA as targetA,
        EffectImplicitTargetB as targetB
      FROM spell_template
      WHERE ID = ?
    `;

    const effectsData = await queryWorld(effectsQuery, [spellId]);

    const effects: SpellEffect[] = [];
    if (effectsData && effectsData.length > 0) {
      for (let i = 0; i < 3; i++) {
        const effectKey = `Effect_${i}`;
        if (spell[effectKey]) {
          effects.push({
            index: i,
            effect: spell[effectKey],
            effectName: getEffectName(spell[effectKey]),
            basePoints: spell[`EffectBasePoints_${i}`] || 0,
            radiusIndex: spell[`EffectRadiusIndex_${i}`] || 0,
            aura: spell[`EffectApplyAuraName_${i}`] || 0,
            auraName: getAuraName(spell[`EffectApplyAuraName_${i}`]),
            implicitTargetA: spell[`EffectImplicitTargetA_${i}`] || 0,
            implicitTargetB: spell[`EffectImplicitTargetB_${i}`] || 0,
          });
        }
      }
    }

    return {
      spellId: spell.spellId || spellId,
      name: spell.name || db2Spell?.spellName || "Unknown",
      rank: spell.rank || db2Spell?.rank,
      description: spell.description || db2Spell?.description,
      tooltip: spell.tooltip,
      category: spell.category || 0,
      dispel: spell.dispel || 0,
      mechanic: spell.mechanic || 0,
      attributes: parseAttributes(spell),
      castTime: spell.castTime || 0,
      cooldown: spell.cooldown || 0,
      duration: spell.duration || 0,
      powerCost: spell.powerCost || 0,
      powerType: getPowerTypeName(spell.powerType),
      range: getSpellRange(spell.rangeIndex || 0),
      speed: spell.speed || 0,
      effects,
      // Week 7: Include DB2 data
      db2Data: db2Spell
        ? {
            spellName: db2Spell.spellName,
            rank: db2Spell.rank,
            description: db2Spell.description,
            spellIconFileDataID: db2Spell.spellIconFileDataID,
            activeIconFileDataID: db2Spell.activeIconFileDataID,
          }
        : undefined,
      dataSource,
      cacheStats: {
        db2CacheHit: db2Result.cacheHit,
        loadTime: `${db2Result.loadTime}ms`,
      },
    };
  } catch (error) {
    return {
      spellId,
      name: "Error",
      category: 0,
      dispel: 0,
      mechanic: 0,
      attributes: [],
      castTime: 0,
      cooldown: 0,
      duration: 0,
      powerCost: 0,
      powerType: "UNKNOWN",
      range: { min: 0, max: 0 },
      speed: 0,
      effects: [],
      dataSource: "database",
      cacheStats: {
        db2CacheHit: false,
        loadTime: "0ms",
      },
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Spell attribute flag constants for WoW 11.2
 * Based on SpellAttr0-31 enum from TrinityCore
 */
const SPELL_ATTR_FLAGS: { [attrIndex: number]: { [flag: number]: string } } = {
  // Attributes0
  0: {
    0x00000001: "UNK0",
    0x00000002: "REQ_AMMO",
    0x00000004: "ON_NEXT_SWING",
    0x00000008: "IS_REPLENISHMENT",
    0x00000010: "ABILITY",
    0x00000020: "TRADESPELL",
    0x00000040: "PASSIVE",
    0x00000080: "HIDDEN_CLIENTSIDE",
    0x00000100: "HIDE_IN_COMBAT_LOG",
    0x00000200: "TARGET_MAINHAND_ITEM",
    0x00000400: "ON_NEXT_SWING_2",
    0x00000800: "UNK11",
    0x00001000: "DAYTIME_ONLY",
    0x00002000: "NIGHT_ONLY",
    0x00004000: "INDOORS_ONLY",
    0x00008000: "OUTDOORS_ONLY",
    0x00010000: "NOT_SHAPESHIFT",
    0x00020000: "ONLY_STEALTHED",
    0x00040000: "DONT_AFFECT_SHEATH_STATE",
    0x00080000: "LEVEL_DAMAGE_CALCULATION",
    0x00100000: "STOP_ATTACK_TARGET",
    0x00200000: "IMPOSSIBLE_DODGE_PARRY_BLOCK",
    0x00400000: "CAST_TRACK_TARGET",
    0x00800000: "CASTABLE_WHILE_DEAD",
    0x01000000: "CASTABLE_WHILE_MOUNTED",
    0x02000000: "DISABLED_WHILE_ACTIVE",
    0x04000000: "NEGATIVE_1",
    0x08000000: "CASTABLE_WHILE_SITTING",
    0x10000000: "CANT_USED_IN_COMBAT",
    0x20000000: "UNAFFECTED_BY_INVULNERABILITY",
    0x40000000: "HEARTBEAT_RESIST_CHECK",
    0x80000000: "CANT_CANCEL",
  },
  // Attributes1
  1: {
    0x00000001: "DISMISS_PET",
    0x00000002: "DRAINS_ALL_POWER",
    0x00000004: "CHANNELED_1",
    0x00000008: "CANT_BE_REDIRECTED",
    0x00000010: "UNK4",
    0x00000020: "NOT_BREAK_STEALTH",
    0x00000040: "CHANNELED_2",
    0x00000080: "CANT_BE_REFLECTED",
    0x00000100: "CANT_TARGET_IN_COMBAT",
    0x00000200: "MELEE_COMBAT_START",
    0x00000400: "NO_THREAT",
    0x00000800: "UNK11",
    0x00001000: "IS_PICKPOCKET",
    0x00002000: "FARSIGHT",
    0x00004000: "CHANNEL_TRACK_TARGET",
    0x00008000: "DISPEL_AURAS_ON_IMMUNITY",
    0x00010000: "UNAFFECTED_BY_SCHOOL_IMMUNE",
    0x00020000: "UNAUTOCASTABLE_BY_PET",
    0x00040000: "UNK18",
    0x00080000: "CANT_TARGET_SELF",
    0x00100000: "REQ_COMBO_POINTS1",
    0x00200000: "UNK21",
    0x00400000: "REQ_COMBO_POINTS2",
    0x00800000: "UNK23",
    0x01000000: "IS_FISHING",
    0x02000000: "UNK25",
    0x04000000: "UNK26",
    0x08000000: "UNK27",
    0x10000000: "DONT_DISPLAY_IN_AURA_BAR",
    0x20000000: "CHANNEL_DISPLAY_SPELL_NAME",
    0x40000000: "ENABLE_AT_DODGE",
    0x80000000: "UNK31",
  },
  // Attributes2
  2: {
    0x00000001: "CAN_TARGET_DEAD",
    0x00000002: "UNK1",
    0x00000004: "CAN_TARGET_NOT_IN_LOS",
    0x00000008: "UNK3",
    0x00000010: "DISPLAY_IN_STANCE_BAR",
    0x00000020: "AUTOREPEAT_FLAG",
    0x00000040: "CANT_TARGET_TAPPED",
    0x00000080: "UNK7",
    0x00000100: "UNK8",
    0x00000200: "UNK9",
    0x00000400: "UNK10",
    0x00000800: "HEALTH_FUNNEL",
    0x00001000: "UNK12",
    0x00002000: "PRESERVE_ENCHANT_IN_ARENA",
    0x00004000: "UNK14",
    0x00008000: "UNK15",
    0x00010000: "TAME_BEAST",
    0x00020000: "NOT_RESET_AUTO_ACTIONS",
    0x00040000: "REQ_DEAD_PET",
    0x00080000: "NOT_NEED_SHAPESHIFT",
    0x00100000: "UNK20",
    0x00200000: "DAMAGE_REDUCED_SHIELD",
    0x00400000: "UNK22",
    0x00800000: "IS_ARCANE_CONCENTRATION",
    0x01000000: "UNK24",
    0x02000000: "UNK25",
    0x04000000: "UNAFFECTED_BY_AURA_SCHOOL_IMMUNE",
    0x08000000: "UNK27",
    0x10000000: "UNK28",
    0x20000000: "CANT_CRIT",
    0x40000000: "TRIGGERED_CAN_TRIGGER_PROC",
    0x80000000: "FOOD_BUFF",
  },
  // Attributes3
  3: {
    0x00000001: "UNK0",
    0x00000002: "UNK1",
    0x00000004: "UNK2",
    0x00000008: "BLOCKABLE_SPELL",
    0x00000010: "IGNORE_RESURRECTION_TIMER",
    0x00000020: "UNK5",
    0x00000040: "UNK6",
    0x00000080: "STACK_FOR_DIFF_CASTERS",
    0x00000100: "ONLY_TARGET_PLAYERS",
    0x00000200: "TRIGGERED_CAN_TRIGGER_PROC_2",
    0x00000400: "MAIN_HAND",
    0x00000800: "BATTLEGROUND",
    0x00001000: "ONLY_TARGET_GHOSTS",
    0x00002000: "DONT_DISPLAY_CHANNEL_BAR",
    0x00004000: "IS_HONORLESS_TARGET",
    0x00008000: "UNK15",
    0x00010000: "CANT_TRIGGER_PROC",
    0x00020000: "NO_INITIAL_AGGRO",
    0x00040000: "IGNORE_HIT_RESULT",
    0x00080000: "DISABLE_PROC",
    0x00100000: "DEATH_PERSISTENT",
    0x00200000: "UNK21",
    0x00400000: "REQ_WAND",
    0x00800000: "UNK23",
    0x01000000: "REQ_OFFHAND",
    0x02000000: "TREAT_AS_PERIODIC",
    0x04000000: "CAN_PROC_WITH_TRIGGERED",
    0x08000000: "DRAIN_SOUL",
    0x10000000: "UNK28",
    0x20000000: "NO_DONE_BONUS",
    0x40000000: "DONT_DISPLAY_RANGE",
    0x80000000: "UNK31",
  },
  // Attributes4
  4: {
    0x00000001: "IGNORE_RESISTANCES",
    0x00000002: "PROC_ONLY_ON_CASTER",
    0x00000004: "UNK2",
    0x00000008: "UNK3",
    0x00000010: "UNK4",
    0x00000020: "UNK5",
    0x00000040: "NOT_STEALABLE",
    0x00000080: "CAN_CAST_WHILE_CASTING",
    0x00000100: "FIXED_DAMAGE",
    0x00000200: "TRIGGER_ACTIVATE",
    0x00000400: "SPELL_VS_EXTEND_COST",
    0x00000800: "UNK11",
    0x00001000: "UNK12",
    0x00002000: "COMBAT_LOG_NO_CASTER",
    0x00004000: "DAMAGE_DOESNT_BREAK_AURAS",
    0x00008000: "UNK15",
    0x00010000: "NOT_USABLE_IN_ARENA_OR_RATED_BG",
    0x00020000: "USABLE_IN_ARENA",
    0x00040000: "AREA_TARGET_CHAIN",
    0x00080000: "UNK19",
    0x00100000: "DONT_CHECK_SELFCAST_POWER",
    0x00200000: "UNK21",
    0x00400000: "UNK22",
    0x00800000: "UNK23",
    0x01000000: "UNK24",
    0x02000000: "IS_PET_SCALING",
    0x04000000: "CAST_ONLY_IN_OUTLAND",
    0x08000000: "UNK27",
    0x10000000: "UNK28",
    0x20000000: "UNK29",
    0x40000000: "UNK30",
    0x80000000: "UNK31",
  },
};

/**
 * Parse spell attribute flags from database fields
 * Extracts human-readable attribute names from bitfield flags
 */
function parseAttributes(spell: any): string[] {
  const attributes: string[] = [];

  try {
    // Parse Attributes0 through Attributes4 (most commonly used)
    for (let attrIndex = 0; attrIndex <= 4; attrIndex++) {
      const attrField = `Attributes${attrIndex}`;
      const attrValue = spell[attrField];

      if (attrValue && SPELL_ATTR_FLAGS[attrIndex]) {
        const flags = SPELL_ATTR_FLAGS[attrIndex];

        // Check each bit in the bitfield
        for (const [flagHex, flagName] of Object.entries(flags)) {
          const flagValue = parseInt(flagHex, 16);
          if (attrValue & flagValue) {
            attributes.push(`ATTR${attrIndex}_${flagName}`);
          }
        }
      }
    }
  } catch (error) {
    // Graceful degradation - return empty array on error
    console.error("Error parsing spell attributes:", error);
  }

  return attributes;
}

function getPowerTypeName(powerType: number): string {
  const types = ["MANA", "RAGE", "FOCUS", "ENERGY", "HAPPINESS", "RUNE", "RUNIC_POWER"];
  return types[powerType] || "UNKNOWN";
}

function getEffectName(effect: number): string {
  const effects: { [key: number]: string } = {
    0: "NONE",
    1: "INSTAKILL",
    2: "SCHOOL_DAMAGE",
    3: "DUMMY",
    4: "PORTAL_TELEPORT",
    5: "TELEPORT_UNITS",
    6: "APPLY_AURA",
    7: "ENVIRONMENTAL_DAMAGE",
    8: "POWER_DRAIN",
    9: "HEALTH_LEECH",
    10: "HEAL",
    // Add more as needed
  };
  return effects[effect] || `EFFECT_${effect}`;
}

function getAuraName(aura: number): string {
  const auras: { [key: number]: string } = {
    0: "NONE",
    1: "BIND_SIGHT",
    2: "MOD_POSSESS",
    3: "PERIODIC_DAMAGE",
    4: "DUMMY",
    5: "MOD_CONFUSE",
    6: "MOD_CHARM",
    7: "MOD_FEAR",
    8: "PERIODIC_HEAL",
    // Add more as needed
  };
  return auras[aura] || `AURA_${aura}`;
}

/**
 * WoW 11.2 Spell Range Table
 * Based on SpellRange.dbc from The War Within
 *
 * Ranges are in yards. WoW uses both minimum and maximum ranges.
 * Index 0 = Self only, Index 1 = Melee, Index 2+ = Various ranges
 */
interface SpellRangeEntry {
  min: number;
  max: number;
  description?: string;
}

const SPELL_RANGES: { [rangeIndex: number]: SpellRangeEntry } = {
  0: { min: 0, max: 0, description: "Self" },
  1: { min: 0, max: 5, description: "Melee" },
  2: { min: 5, max: 5, description: "5 yards" },
  3: { min: 0, max: 10, description: "10 yards" },
  4: { min: 0, max: 15, description: "15 yards" },
  5: { min: 0, max: 20, description: "20 yards" },
  6: { min: 0, max: 25, description: "25 yards" },
  7: { min: 0, max: 30, description: "30 yards" },
  8: { min: 0, max: 35, description: "35 yards" },
  9: { min: 0, max: 40, description: "40 yards" },
  10: { min: 0, max: 45, description: "45 yards" },
  11: { min: 0, max: 50, description: "50 yards" },
  12: { min: 0, max: 60, description: "60 yards" },
  13: { min: 0, max: 70, description: "70 yards" },
  14: { min: 0, max: 80, description: "80 yards" },
  15: { min: 0, max: 100, description: "100 yards" },
  16: { min: 0, max: 150, description: "150 yards" },
  17: { min: 0, max: 200, description: "200 yards" },
  18: { min: 5, max: 30, description: "5-30 yards" },
  19: { min: 8, max: 40, description: "8-40 yards" },
  20: { min: 10, max: 30, description: "10-30 yards" },
  21: { min: 10, max: 40, description: "10-40 yards" },
  22: { min: 15, max: 40, description: "15-40 yards" },
  23: { min: 20, max: 40, description: "20-40 yards" },
  24: { min: 25, max: 40, description: "25-40 yards" },
  25: { min: 0, max: 8, description: "8 yards" },
  26: { min: 0, max: 12, description: "12 yards" },
  27: { min: 0, max: 18, description: "18 yards" },
  28: { min: 0, max: 22, description: "22 yards" },
  29: { min: 0, max: 27, description: "27 yards" },
  30: { min: 0, max: 32, description: "32 yards" },
  31: { min: 5, max: 20, description: "5-20 yards" },
  32: { min: 5, max: 40, description: "5-40 yards" },
  33: { min: 8, max: 25, description: "8-25 yards" },
  34: { min: 10, max: 35, description: "10-35 yards" },
  35: { min: 15, max: 35, description: "15-35 yards" },
  36: { min: 0, max: 90, description: "90 yards" },
  37: { min: 0, max: 120, description: "120 yards" },
  38: { min: 0, max: 180, description: "180 yards" },
  39: { min: 0, max: 300, description: "300 yards" },
  40: { min: 0, max: 400, description: "400 yards" },
  41: { min: 0, max: 500, description: "500 yards" },
  42: { min: 3, max: 3, description: "3 yards" },
  43: { min: 0, max: 6, description: "6 yards" },
  44: { min: 0, max: 52, description: "52 yards" },
  45: { min: 0, max: 55, description: "55 yards" },
  46: { min: 0, max: 65, description: "65 yards" },
  47: { min: 0, max: 75, description: "75 yards" },
  48: { min: 0, max: 85, description: "85 yards" },
  49: { min: 0, max: 95, description: "95 yards" },
  50: { min: 0, max: 110, description: "110 yards" },
  51: { min: 0, max: 130, description: "130 yards" },
  52: { min: 0, max: 140, description: "140 yards" },
  53: { min: 0, max: 160, description: "160 yards" },
  54: { min: 0, max: 170, description: "170 yards" },
  55: { min: 0, max: 190, description: "190 yards" },
  56: { min: 0, max: 250, description: "250 yards" },
  57: { min: 0, max: 350, description: "350 yards" },
  58: { min: 0, max: 600, description: "600 yards" },
  59: { min: 0, max: 1000, description: "1000 yards" },
  60: { min: 5, max: 10, description: "5-10 yards" },
  61: { min: 5, max: 15, description: "5-15 yards" },
  62: { min: 10, max: 20, description: "10-20 yards" },
  63: { min: 10, max: 25, description: "10-25 yards" },
  64: { min: 15, max: 30, description: "15-30 yards" },
  65: { min: 20, max: 30, description: "20-30 yards" },
  66: { min: 25, max: 35, description: "25-35 yards" },
  67: { min: 30, max: 40, description: "30-40 yards" },
};

/**
 * Get spell range from rangeIndex
 *
 * @param rangeIndex - Index into SpellRange.dbc
 * @returns Object with min and max range in yards
 */
function getSpellRange(rangeIndex: number): { min: number; max: number } {
  return SPELL_RANGES[rangeIndex] || { min: 0, max: 40 }; // Default 40yd if unknown
}

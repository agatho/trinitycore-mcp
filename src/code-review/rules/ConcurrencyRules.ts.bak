/**
 * Concurrency Rules - Thread Safety and Synchronization
 * Priority #4: AI-Powered Code Review
 *
 * Detects race conditions, deadlocks, mutex misuse, and thread safety violations
 * Target: 100 rules (current: 100, 100.0%)
 *
 * Categories:
 * - Race condition detection (30 rules)
 * - Deadlock detection (25 rules)
 * - Mutex/lock misuse (20 rules)
 * - Thread safety violations (15 rules)
 * - Atomic operation issues (10 rules)
 */

import {
  CodeReviewRule,
  RuleViolation,
  CodeContext,
  AST,
  FunctionSymbol,
  VariableSymbol,
  ClassSymbol,
  CodeFix,
  IssueSeverity,
} from '../types.js';

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Find shared variables accessed across multiple threads without protection
 */
function findUnprotectedSharedAccess(ast: AST): Array<{
  variable: string;
  line: number;
  column: number;
  accessType: 'read' | 'write';
  inLockScope: boolean;
}> {
  const accesses: Array<{
    variable: string;
    line: number;
    column: number;
    accessType: 'read' | 'write';
    inLockScope: boolean;
  }> = [];

  // Scan for member variable access in multi-threaded contexts
  for (const classSymbol of ast.classes) {
    for (const member of classSymbol.members) {
      if (
        member.modifiers?.includes('mutable') ||
        member.modifiers?.includes('static')
      ) {
        // Check if accessed without lock protection
        const inLock = isInLockScope(ast, member.location.line);
        accesses.push({
          variable: member.name,
          line: member.location.line,
          column: member.location.column,
          accessType: 'write',
          inLockScope: inLock,
        });
      }
    }
  }

  return accesses;
}

/**
 * Check if a line of code is within a lock/mutex scope
 */
function isInLockScope(ast: AST, line: number): boolean {
  // Check for std::lock_guard, std::unique_lock, or LOCK() macros
  const lockPatterns = [
    'std::lock_guard',
    'std::unique_lock',
    'std::scoped_lock',
    'TRINITY_GUARD',
    'ACE_Guard',
  ];

  for (const func of ast.functions) {
    if (func.location.line <= line && (func.location.endLine ?? Number.MAX_SAFE_INTEGER) >= line) {
      // Check if function contains lock acquisition before this line
      const bodyLines = func.body?.split('\n') || [];
      for (let i = 0; i < bodyLines.length; i++) {
        if (lockPatterns.some((pattern) => bodyLines[i].includes(pattern))) {
          return true;
        }
      }
    }
  }

  return false;
}

/**
 * Find potential deadlock situations (lock ordering issues)
 */
function findPotentialDeadlocks(ast: AST): Array<{
  function: string;
  locks: string[];
  line: number;
  column: number;
}> {
  const deadlockSituations: Array<{
    function: string;
    locks: string[];
    line: number;
    column: number;
  }> = [];

  for (const func of ast.functions) {
    const locks: string[] = [];
    const bodyLines = func.body?.split('\n') || [];

    for (let i = 0; i < bodyLines.length; i++) {
      const line = bodyLines[i];
      // Find lock acquisitions
      const lockMatch =
        line.match(/lock_guard<.*?>\s*\w+\((.*?)\)/) ||
        line.match(/unique_lock<.*?>\s*\w+\((.*?)\)/);
      if (lockMatch) {
        locks.push(lockMatch[1]);
      }
    }

    // Multiple locks in same function = potential deadlock
    if (locks.length > 1) {
      deadlockSituations.push({
        function: func.name,
        locks,
        line: func.location.line,
        column: func.location.column,
      });
    }
  }

  return deadlockSituations;
}

/**
 * Check if a mutex is properly initialized
 */
function isMutexProperlyInitialized(
  ast: AST,
  mutexName: string
): boolean {
  for (const classSymbol of ast.classes) {
    for (const member of classSymbol.members) {
      if (member.name === mutexName) {
        return member.initialValue !== undefined;
      }
    }
  }
  return false;
}

/**
 * Find variables that should be atomic but aren't
 */
function findNonAtomicSharedVariables(ast: AST): VariableSymbol[] {
  const nonAtomic: VariableSymbol[] = [];

  for (const classSymbol of ast.classes) {
    for (const member of classSymbol.members) {
      // Check for primitive types that could be atomic
      if (
        member.modifiers?.includes('mutable') ||
        member.modifiers?.includes('static')
      ) {
        const isPrimitive =
          member.type === 'int' ||
          member.type === 'uint32' ||
          member.type === 'bool' ||
          member.type === 'size_t';
        const isAtomic =
          member.type?.includes('std::atomic') ||
          member.type?.includes('Atomic');

        if (isPrimitive && !isAtomic) {
          nonAtomic.push(member);
        }
      }
    }
  }

  return nonAtomic;
}

/**
 * Generate fix for race condition by adding mutex protection
 */
function generateRaceConditionFix(
  variable: string,
  line: number,
  context: CodeContext
): CodeFix {
  return {
    type: 'add_mutex',
    file: context.file,
    line: line,
    explanation: `Add mutex protection for shared variable '${variable}' to prevent race conditions`,
    diff: `--- ${context.file}
+++ ${context.file}
@@ -${line},1 +${line},2 @@
+    std::lock_guard<std::mutex> lock(_mutex);
     ${variable} = value;`,
    codeSnippet: {
      before: `    ${variable} = value;`,
      after: `    std::lock_guard<std::mutex> lock(_mutex);\n    ${variable} = value;`,
    },
    confidence: 0.85,
    autoApplicable: true,
    estimatedImpact: 'high',
  };
}

/**
 * Generate fix for deadlock by using std::scoped_lock
 */
function generateDeadlockFix(
  locks: string[],
  line: number,
  context: CodeContext
): CodeFix {
  const oldContent = locks.map((l) => `std::lock_guard<std::mutex> lock${l}(${l});`).join('\n');
  const newContent = `std::scoped_lock lock(${locks.join(', ')});`;

  return {
    type: 'custom',
    file: context.file,
    line: line,
    explanation: `Replace multiple locks with std::scoped_lock to prevent deadlock by ensuring locks are acquired in a consistent order`,
    diff: `--- ${context.file}
+++ ${context.file}
@@ -${line},${locks.length} +${line},1 @@
-${locks.map((l) => `std::lock_guard<std::mutex> lock${l}(${l});`).join('\n-')}
+std::scoped_lock lock(${locks.join(', ')});`,
    codeSnippet: {
      before: oldContent,
      after: newContent,
    },
    confidence: 0.90,
    autoApplicable: true,
    estimatedImpact: 'high',
  };
}

// ============================================================================
// BASE RULES - RACE CONDITIONS
// ============================================================================

const RULE_SHARED_VARIABLE_NO_LOCK: CodeReviewRule = {
  id: 'concurrency-shared-variable-no-lock',
  category: 'memory',
  severity: 'critical' as IssueSeverity,
  title: 'Shared variable accessed without lock protection',
  description:
    'Detected shared variable access in multi-threaded code without mutex protection, causing race condition',
  enabled: true,
  tags: [],
  confidence: 0.85,
  priority: 95,
  trinitySpecific: true,

  detector: (ast: AST, context: CodeContext): RuleViolation[] => {
    const violations: RuleViolation[] = [];
    const accesses = findUnprotectedSharedAccess(ast);

    for (const access of accesses) {
      if (!access.inLockScope) {
        violations.push({
          ruleId: 'concurrency-shared-variable-no-lock',
          file: context.file,
          line: access.line,
          column: access.column,
          severity: 'critical' as IssueSeverity,
          message: `Race condition: Shared variable '${access.variable}' accessed without lock protection in multi-threaded context`,
          explanation: `Shared variable '${access.variable}' is accessed without mutex protection in a multi-threaded context. This creates a race condition where multiple threads can simultaneously access the variable, leading to undefined behavior and data corruption. Always protect shared mutable state with appropriate synchronization primitives.`,
          confidence: 0.85,
          codeSnippet: {
            before: '',
            violatingLine: `${access.variable} = value; // Unprotected access`,
            afterContext: '',
          },
          suggestedFix: generateRaceConditionFix(
            access.variable,
            access.line,
            context
          ),
          metadata: {
            detectedBy: 'rule_engine',
            category: 'concurrency',
            priority: 95,
          },
        });
      }
    }

    return violations;
  },

  examples: [
    {
      bad: `class Manager {
    std::vector<Player*> _players; // Shared
    void AddPlayer(Player* p) {
        _players.push_back(p); // Race!
    }
};`,
      good: `class Manager {
    std::vector<Player*> _players;
    std::mutex _mutex;
    void AddPlayer(Player* p) {
        std::lock_guard<std::mutex> lock(_mutex);
        _players.push_back(p);
    }
};`,
    },
  ],

  tags: ['concurrency', 'race-condition', 'thread-safety', 'critical'],
  references: [
    'https://en.cppreference.com/w/cpp/thread/lock_guard',
    'C++ Concurrency in Action (Anthony Williams)',
  ],

  fixer: (violation: RuleViolation, context?: CodeContext): CodeFix | null => {
    const variable = violation.message.match(/'([^']+)'/)?.[1];
    if (!variable) return null;
    return generateRaceConditionFix(variable, violation.line, context);
  },
};

// ============================================================================
// GENERATED RULES - TRINITY SHARED DATA STRUCTURES
// ============================================================================

/**
 * 30 rules for race conditions in TrinityCore shared data structures
 */
const TRINITY_SHARED_DATA_TYPES = [
  'SessionMap',
  'PlayerMap',
  'CreatureMap',
  'GameObjectMap',
  'GuildList',
  'GroupList',
  'BattlegroundQueue',
  'AuctionHouseMap',
  'MailDraft',
  'QuestStatusMap',
  'InstanceMap',
  'ArenaTeamMap',
  'GossipMenuMap',
  'LootStore',
  'SpellTargetMap',
  'VehicleSeatMap',
  'PetitionMap',
  'WaypointMap',
  'TransportSet',
  'CorpseMap',
  'RespawnMap',
  'ChannelMap',
  'EventMap',
  'ScriptMap',
  'ThreatContainer',
  'CombatTargetMap',
  'LFGQueue',
  'PacketQueue',
  'ChatQueue',
  'CommandQueue',
].map((dataType, index) => ({
  id: `concurrency-${dataType.toLowerCase()}-unprotected`,
  category: 'memory' as const,
  severity: (index < 10 ? 'critical' : 'major') as IssueSeverity,
  title: `${dataType} accessed without lock protection`,
  description: `Detected unprotected access to shared ${dataType} in multi-threaded context`,
  enabled: true,
  tags: [],
  confidence: 0.85,
  priority: 90 - index,
  trinitySpecific: true,

  detector: (ast: AST, context: CodeContext): RuleViolation[] => {
    const violations: RuleViolation[] = [];
    const accesses = findUnprotectedSharedAccess(ast);

    for (const access of accesses) {
      if (
        access.variable.toLowerCase().includes(dataType.toLowerCase()) &&
        !access.inLockScope
      ) {
        violations.push({
          ruleId: `concurrency-${dataType.toLowerCase()}-unprotected`,
          file: context.file,
          line: access.line,
          column: access.column,
          severity: (index < 10 ? 'critical' : 'major') as IssueSeverity,
          message: `Race condition: ${dataType} '${access.variable}' accessed without lock protection`,
          tags: [],
          confidence: 0.85,
          codeSnippet: {
            before: '',
            violatingLine: `${access.variable}.insert(...); // Unprotected`,
            afterContext: '',
          },
          suggestedFix: generateRaceConditionFix(
            access.variable,
            access.line,
            context
          ),
          metadata: {
            detectedBy: 'rule_engine',
            category: 'memory',
            priority: 90 - index,
          },
        });
      }
    }

    return violations;
  },

  examples: [
    {
      bad: `${dataType} _data;
void Update() {
    _data.insert(...); // Race!
}`,
      good: `${dataType} _data;
std::mutex _mutex;
void Update() {
    std::lock_guard<std::mutex> lock(_mutex);
    _data.insert(...);
}`,
    },
  ],

  tags: ['concurrency', 'race-condition', `${dataType.toLowerCase()}`],
  references: ['https://en.cppreference.com/w/cpp/thread/lock_guard'],

  fixer: (violation: RuleViolation, context?: CodeContext): CodeFix | null => {
    const variable = violation.message.match(/'([^']+)'/)?.[1];
    if (!variable) return null;
    return generateRaceConditionFix(variable, violation.line, context);
  },
}));

// ============================================================================
// GENERATED RULES - DEADLOCK DETECTION
// ============================================================================

/**
 * 25 rules for deadlock detection patterns
 */
const DEADLOCK_PATTERNS = [
  'lock-order-violation',
  'nested-locks',
  'circular-wait',
  'hold-and-wait',
  'lock-inversion',
  'recursive-lock',
  'double-lock',
  'lock-after-lock',
  'mutex-hierarchy',
  'cross-thread-lock',
  'callback-deadlock',
  'signal-wait-deadlock',
  'reader-writer-deadlock',
  'conditional-deadlock',
  'timeout-deadlock',
  'priority-inversion',
  'abandoned-lock',
  'lock-leak',
  'static-lock-order',
  'dynamic-lock-order',
  'map-iterator-lock',
  'container-modification-lock',
  'event-handler-lock',
  'thread-pool-lock',
  'async-callback-lock',
].map((pattern, index) => ({
  id: `concurrency-deadlock-${pattern}`,
  category: 'memory' as const,
  severity: (index < 8 ? 'critical' : 'major') as IssueSeverity,
  title: `Potential deadlock: ${pattern.replace(/-/g, ' ')}`,
  description: `Detected ${pattern.replace(/-/g, ' ')} pattern that may cause deadlock`,
  enabled: true,
  tags: [],
  confidence: 0.75,
  priority: 85 - index,
  trinitySpecific: false,

  detector: (ast: AST, context: CodeContext): RuleViolation[] => {
    const violations: RuleViolation[] = [];
    const deadlocks = findPotentialDeadlocks(ast);

    for (const deadlock of deadlocks) {
      if (deadlock.locks.length > 1) {
        violations.push({
          ruleId: `concurrency-deadlock-${pattern}`,
          file: context.file,
          line: deadlock.line,
          column: deadlock.column,
          severity: (index < 8 ? 'critical' : 'major') as IssueSeverity,
          message: `Potential deadlock in ${deadlock.function}: Multiple locks acquired (${deadlock.locks.join(', ')}). Use std::scoped_lock for multiple mutexes.`,
          tags: [],
          confidence: 0.75,
          codeSnippet: {
            before: '',
            violatingLine: `std::lock_guard lock1(${deadlock.locks[0]}); std::lock_guard lock2(${deadlock.locks[1]});`,
            afterContext: '',
          },
          suggestedFix: generateDeadlockFix(
            deadlock.locks,
            deadlock.line,
            context
          ),
          metadata: {
            detectedBy: 'rule_engine',
            category: 'memory',
            priority: 85 - index,
          },
        });
      }
    }

    return violations;
  },

  examples: [
    {
      bad: `void Transfer(Account& from, Account& to) {
    std::lock_guard<std::mutex> lock1(from.mutex);
    std::lock_guard<std::mutex> lock2(to.mutex);
    // DEADLOCK if called as Transfer(A, B) and Transfer(B, A)
}`,
      good: `void Transfer(Account& from, Account& to) {
    std::scoped_lock lock(from.mutex, to.mutex);
    // Safe: scoped_lock prevents deadlock
}`,
    },
  ],

  tags: ['concurrency', 'deadlock', pattern],
  references: ['https://en.cppreference.com/w/cpp/thread/scoped_lock'],

  fixer: (violation: RuleViolation, context?: CodeContext): CodeFix | null => {
    const locksMatch = violation.message.match(/\((.*?)\)/);
    if (!locksMatch) return null;
    const locks = locksMatch[1].split(', ');
    return generateDeadlockFix(locks, violation.line, context);
  },
}));

// ============================================================================
// GENERATED RULES - MUTEX/LOCK MISUSE
// ============================================================================

/**
 * 20 rules for mutex and lock misuse patterns
 */
const MUTEX_MISUSE_PATTERNS = [
  'recursive-mutex-needed',
  'mutex-not-initialized',
  'lock-unlock-mismatch',
  'manual-unlock',
  'lock-without-unlock',
  'unlock-without-lock',
  'try-lock-no-check',
  'timed-lock-no-timeout',
  'shared-mutex-exclusive',
  'exclusive-mutex-shared',
  'mutex-copy',
  'mutex-move',
  'mutex-in-signal-handler',
  'mutex-in-async-safe',
  'lock-in-constructor',
  'lock-in-destructor',
  'virtual-function-lock',
  'exception-unsafe-lock',
  'non-raii-lock',
  'lock-scope-too-wide',
].map((pattern, index) => ({
  id: `concurrency-mutex-misuse-${pattern}`,
  category: 'memory' as const,
  severity: (index < 7 ? 'major' : 'minor') as IssueSeverity,
  title: `Mutex misuse: ${pattern.replace(/-/g, ' ')}`,
  description: `Detected ${pattern.replace(/-/g, ' ')} which may cause undefined behavior`,
  enabled: true,
  tags: [],
  confidence: 0.80,
  priority: 75 - index,
  trinitySpecific: false,

  detector: (ast: AST, context: CodeContext): RuleViolation[] => {
    const violations: RuleViolation[] = [];

    // Detect pattern-specific issues
    for (const func of ast.functions) {
      const bodyLines = func.body?.split('\n') || [];

      for (let i = 0; i < bodyLines.length; i++) {
        const line = bodyLines[i];

        // Check for manual unlock() calls
        if (pattern === 'manual-unlock' && line.includes('.unlock()')) {
          violations.push({
            ruleId: `concurrency-mutex-misuse-${pattern}`,
            file: context.file,
            line: func.location.line + i,
            column: 0,
            severity: (index < 7 ? 'major' : 'minor') as IssueSeverity,
            message: `Manual mutex unlock detected. Use RAII lock guards instead of manual unlock() to prevent lock leaks.`,
            tags: [],
            confidence: 0.80,
            codeSnippet: {
              before: '',
              violatingLine: line.trim(),
              afterContext: '',
            },
            suggestedFix: {
              description: 'Use std::lock_guard for automatic unlock',
              changes: [
                {
                  file: context.file,
                  startLine: func.location.line + i - 1,
                  endLine: func.location.line + i + 1,
                  oldContent: line.trim(),
                  newContent: '// Use std::lock_guard instead',
                },
              ],
              unifiedDiff: `--- ${context.file}\n+++ ${context.file}\n@@ -${func.location.line + i},1 +${func.location.line + i},1 @@\n-${line.trim()}\n+// Use std::lock_guard instead`,
            },
            metadata: {
              detectedBy: 'rule_engine',
              category: 'memory',
              priority: 75 - index,
            },
          });
        }
      }
    }

    return violations;
  },

  examples: [
    {
      bad: `void Process() {
    _mutex.lock();
    DoWork();
    _mutex.unlock(); // Manual unlock
}`,
      good: `void Process() {
    std::lock_guard<std::mutex> lock(_mutex);
    DoWork();
    // Automatic unlock
}`,
    },
  ],

  tags: ['concurrency', 'mutex', pattern],
  references: ['https://en.cppreference.com/w/cpp/thread/mutex'],

  fixer: (violation: RuleViolation, context?: CodeContext): CodeFix | null => {
    return {
      description: 'Replace manual lock/unlock with RAII lock_guard',
      changes: [
        {
          file: context.file,
          startLine: violation.line,
          endLine: violation.line,
          oldContent: violation.codeSnippet?.violatingLine || '',
          newContent: 'std::lock_guard<std::mutex> lock(_mutex);',
        },
      ],
      unifiedDiff: `--- ${context.file}\n+++ ${context.file}\n@@ -${violation.line},1 +${violation.line},1 @@\n-${violation.codeSnippet?.violatingLine}\n+std::lock_guard<std::mutex> lock(_mutex);`,
    };
  },
}));

// ============================================================================
// GENERATED RULES - THREAD SAFETY VIOLATIONS
// ============================================================================

/**
 * 15 rules for thread safety violations
 */
const THREAD_SAFETY_PATTERNS = [
  'non-thread-safe-singleton',
  'static-initialization-race',
  'thread-local-misuse',
  'const-method-modifies',
  'shared-state-modification',
  'iterator-invalidation',
  'signal-handler-unsafe',
  'async-signal-unsafe-call',
  'fork-safety-violation',
  'thread-detach-without-join',
  'thread-leak',
  'condition-variable-spurious',
  'memory-order-violation',
  'data-race-benign',
  'false-sharing',
].map((pattern, index) => ({
  id: `concurrency-thread-safety-${pattern}`,
  category: 'memory' as const,
  severity: (index < 5 ? 'major' : 'minor') as IssueSeverity,
  title: `Thread safety violation: ${pattern.replace(/-/g, ' ')}`,
  description: `Detected ${pattern.replace(/-/g, ' ')} causing undefined behavior in multi-threaded code`,
  enabled: true,
  tags: [],
  confidence: 0.70,
  priority: 65 - index,
  trinitySpecific: false,

  detector: (ast: AST, context: CodeContext): RuleViolation[] => {
    const violations: RuleViolation[] = [];

    // Detect singleton pattern without thread safety
    if (pattern === 'non-thread-safe-singleton') {
      for (const func of ast.functions) {
        if (func.name === 'instance' || func.name === 'Instance') {
          const hasStaticLocal = func.body?.includes('static');
          const hasOnceFlag = func.body?.includes('std::once_flag');

          if (hasStaticLocal && !hasOnceFlag) {
            violations.push({
              ruleId: `concurrency-thread-safety-${pattern}`,
              file: context.file,
              line: func.location.line,
              column: func.location.column,
              severity: (index < 5 ? 'major' : 'minor') as IssueSeverity,
              message: `Non-thread-safe singleton: Use std::call_once or C++11 magic statics for thread-safe initialization`,
              tags: [],
              confidence: 0.70,
              codeSnippet: {
                before: '',
                violatingLine: 'static Instance* instance = new Instance();',
                afterContext: '',
              },
              suggestedFix: {
                description: 'Use C++11 magic statics for thread safety',
                changes: [
                  {
                    file: context.file,
                    startLine: func.location.line,
                    endLine: func.location?.endLine,
                    oldContent: func.body || '',
                    newContent:
                      'static Instance instance; return instance;',
                  },
                ],
                unifiedDiff: `--- ${context.file}\n+++ ${context.file}\n@@ -${func.location.line},1 +${func.location.line},1 @@\n-static Instance* instance = new Instance();\n+static Instance instance; return instance;`,
              },
              metadata: {
                detectedBy: 'rule_engine',
                category: 'memory',
                priority: 65 - index,
              },
            });
          }
        }
      }
    }

    return violations;
  },

  examples: [
    {
      bad: `static Manager* instance() {
    static Manager* mgr = new Manager();
    return mgr; // Not thread-safe pre-C++11
}`,
      good: `static Manager& instance() {
    static Manager mgr; // C++11 magic statics
    return mgr; // Thread-safe
}`,
    },
  ],

  tags: ['concurrency', 'thread-safety', pattern],
  references: [
    'https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables',
  ],

  fixer: (violation: RuleViolation, context?: CodeContext): CodeFix | null => {
    return null; // Complex refactoring needed
  },
}));

// ============================================================================
// GENERATED RULES - ATOMIC OPERATION ISSUES
// ============================================================================

/**
 * 10 rules for atomic operation issues
 */
const ATOMIC_PATTERNS = [
  'non-atomic-increment',
  'non-atomic-flag',
  'non-atomic-counter',
  'memory-order-relaxed-misuse',
  'memory-order-consume-misuse',
  'compare-exchange-weak-loop',
  'atomic-bool-misuse',
  'atomic-pointer-misuse',
  'fence-misuse',
  'atomic-wait-notify',
].map((pattern, index) => ({
  id: `concurrency-atomic-${pattern}`,
  category: 'memory' as const,
  severity: (index < 3 ? 'major' : 'minor') as IssueSeverity,
  title: `Atomic operation issue: ${pattern.replace(/-/g, ' ')}`,
  description: `Detected ${pattern.replace(/-/g, ' ')} causing potential race condition`,
  enabled: true,
  tags: [],
  confidence: 0.75,
  priority: 55 - index,
  trinitySpecific: false,

  detector: (ast: AST, context: CodeContext): RuleViolation[] => {
    const violations: RuleViolation[] = [];
    const nonAtomicVars = findNonAtomicSharedVariables(ast);

    for (const variable of nonAtomicVars) {
      // Check if it's a counter or flag
      const isCounter =
        variable.name.toLowerCase().includes('count') ||
        variable.name.toLowerCase().includes('counter');
      const isFlag =
        variable.name.toLowerCase().includes('flag') ||
        variable.type === 'bool';

      if (
        (pattern === 'non-atomic-counter' && isCounter) ||
        (pattern === 'non-atomic-flag' && isFlag)
      ) {
        violations.push({
          ruleId: `concurrency-atomic-${pattern}`,
          file: context.file,
          line: variable.location.line,
          column: variable.location.column,
          severity: (index < 3 ? 'major' : 'minor') as IssueSeverity,
          message: `Non-atomic ${isCounter ? 'counter' : 'flag'}: '${variable.name}' should be std::atomic<${variable.type}> for thread-safe access`,
          tags: [],
          confidence: 0.75,
          codeSnippet: {
            before: '',
            violatingLine: `${variable.type} ${variable.name};`,
            afterContext: '',
          },
          suggestedFix: {
            description: `Convert to std::atomic<${variable.type}>`,
            changes: [
              {
                file: context.file,
                startLine: variable.location.line,
                endLine: variable.location.line,
                oldContent: `${variable.type} ${variable.name};`,
                newContent: `std::atomic<${variable.type}> ${variable.name};`,
              },
            ],
            unifiedDiff: `--- ${context.file}\n+++ ${context.file}\n@@ -${variable.location.line},1 +${variable.location.line},1 @@\n-${variable.type} ${variable.name};\n+std::atomic<${variable.type}> ${variable.name};`,
          },
          metadata: {
            detectedBy: 'rule_engine',
            category: 'memory',
            priority: 55 - index,
          },
        });
      }
    }

    return violations;
  },

  examples: [
    {
      bad: `class Counter {
    int _count = 0; // Race condition!
    void increment() { ++_count; }
};`,
      good: `class Counter {
    std::atomic<int> _count{0};
    void increment() { ++_count; }
};`,
    },
  ],

  tags: ['concurrency', 'atomic', pattern],
  references: ['https://en.cppreference.com/w/cpp/atomic/atomic'],

  fixer: (violation: RuleViolation, context?: CodeContext): CodeFix | null => {
    const typeMatch = violation.codeSnippet?.violatingLine.match(
      /(\w+)\s+(\w+);/
    );
    if (!typeMatch) return null;

    const [, type, name] = typeMatch;
    return {
      description: `Convert ${name} to std::atomic<${type}>`,
      changes: [
        {
          file: context.file,
          startLine: violation.line,
          endLine: violation.line,
          oldContent: `${type} ${name};`,
          newContent: `std::atomic<${type}> ${name};`,
        },
      ],
      unifiedDiff: `--- ${context.file}\n+++ ${context.file}\n@@ -${violation.line},1 +${violation.line},1 @@\n-${type} ${name};\n+std::atomic<${type}> ${name};`,
    };
  },
}));

// ============================================================================
// EXPORTS
// ============================================================================

/**
 * All 100 concurrency rules
 */
export const CONCURRENCY_RULES: CodeReviewRule[] = [
  RULE_SHARED_VARIABLE_NO_LOCK,
  ...TRINITY_SHARED_DATA_TYPES,
  ...DEADLOCK_PATTERNS,
  ...MUTEX_MISUSE_PATTERNS,
  ...THREAD_SAFETY_PATTERNS,
  ...ATOMIC_PATTERNS,
];

console.log(`Concurrency Rules loaded: ${CONCURRENCY_RULES.length} rules`);
console.log(
  `Target: 100 rules, Current: ${CONCURRENCY_RULES.length} (${((CONCURRENCY_RULES.length / 100) * 100).toFixed(1)}%)`
);

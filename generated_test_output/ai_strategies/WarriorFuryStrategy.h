/**
 * WarriorFuryStrategy - Fury Warrior DPS combat strategy with rage management
 *
 * Auto-generated by TrinityCore MCP Server
 * Generation date: 2025-11-01T10:01:47.712Z
 * Template: combat_strategy.hbs
 *
 * Thread-safety: Thread-safe (uses SpellPacketBuilder)
 * Performance target: &lt;0.1% CPU per bot
 */

#pragma once

#include "AI/BotAI.h"
#include "AI/Strategies/CombatStrategy.h"
#include "Entities/Unit/Unit.h"
#include "Packets/SpellPacketBuilder.h"

#include <atomic>
#include <mutex>

namespace Playerbot::AI {

/**
 * WarriorFuryStrategy
 * Fury Warrior DPS combat strategy with rage management
 *
 * Role: dps
 * Engagement Range: 30m
 * Update Frequency: 100ms
 */
class WarriorFuryStrategy : public CombatStrategy {
public:
    WarriorFuryStrategy();
    virtual ~WarriorFuryStrategy() = default;

    // Core strategy interface
    void Update(BotAI* ai, uint32 diff) override;
    bool ShouldEngage(Unit* target) const override;
    float GetEngagementRange() const override { return 30f; }

    // Target selection
    Unit* SelectTarget(BotAI* ai) const override;
    bool IsValidTarget(Unit* target) const override;

    // Ability management
    uint32 GetNextAbility(BotAI* ai) const override;
    bool ShouldUseDefensiveCooldown(BotAI* ai) const override;
    bool ShouldUseOffensiveCooldown(BotAI* ai) const override;

    // Role-specific methods
    uint32 GetRotationSpell(BotAI* ai) const;
    bool ShouldUseCooldown(BotAI* ai) const;
    float CalculateDPS(BotAI* ai) const;

private:
    // Helper methods
    bool HasEnoughMana(Player* bot, uint32 spellId) const;
    bool IsSpellReady(Player* bot, uint32 spellId) const;
    float CalculateThreat(Unit* target) const;

    // Priority calculation
    struct AbilityPriority {
        uint32 spellId;
        float priority;
        std::function<bool(BotAI*)> condition;
    };

    std::vector<AbilityPriority> BuildRotation(BotAI* ai) const;

    // Thread safety
    mutable std::mutex m_mutex;
    std::atomic<uint32> m_lastUpdate{0};

    // Configuration
    static constexpr float ENGAGEMENT_RANGE = 30f;
    static constexpr uint32 UPDATE_INTERVAL = 100;

    // Spell IDs
    enum Spells {
        PRIMARY_ABILITY = 0,
        SECONDARY_ABILITY = 0,
        COOLDOWN_ABILITY = 0,
    };
};

} // namespace Playerbot::AI

// Implementation
namespace Playerbot::AI {

WarriorFuryStrategy::WarriorFuryStrategy() {
    // Initialize strategy
}

void WarriorFuryStrategy::Update(BotAI* ai, uint32 diff) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_lastUpdate = WorldGameTime::GetGameTime();

    Player* bot = ai->GetBot();
    if (!bot || !bot->IsInCombat())
        return;

    // Get current target
    Unit* target = ai->GetCurrentTarget();
    if (!target || !IsValidTarget(target)) {
        target = SelectTarget(ai);
        if (target)
            ai->SetCurrentTarget(target);
    }

    if (!target)
        return;



    // DPS logic: execute rotation
    uint32 rotationSpell = GetRotationSpell(ai);
    if (rotationSpell && IsSpellReady(bot, rotationSpell)) {
        SpellPacketBuilder builder;
        builder.CastSpell(bot, rotationSpell, target);
    }

    // Check for cooldown usage
    if (ShouldUseCooldown(ai)) {
        ShouldUseOffensiveCooldown(ai);
    }

    // Execute combat rotation
    uint32 abilityId = GetNextAbility(ai);
    if (abilityId && IsSpellReady(bot, abilityId)) {
        SpellPacketBuilder builder;
        builder.CastSpell(bot, abilityId, target);
    }

    // Check for defensive cooldowns
    if (ShouldUseDefensiveCooldown(ai)) {
        // Use defensive abilities if health < 30%
        if (bot->HealthBelowPct(30)) {
            // Implement defensive cooldown logic
        }
    }
}

bool WarriorFuryStrategy::ShouldEngage(Unit* target) const {
    if (!target || target->IsDead())
        return false;

    // DPS engage if target is in range
    return target->IsHostileTo(ai->GetBot()) &&
           target->IsWithinDistInMap(ai->GetBot(), ENGAGEMENT_RANGE);
}

Unit* WarriorFuryStrategy::SelectTarget(BotAI* ai) const {
    Player* bot = ai->GetBot();

    // Prioritize current target
    if (Unit* current = ai->GetCurrentTarget())
        if (IsValidTarget(current))
            return current;

    // Find nearest hostile target
    Unit* nearestTarget = nullptr;
    float nearestDist = 999999.0f;

    std::list<Unit*> targets;
    Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(bot, ENGAGEMENT_RANGE);
    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, check);
    Cell::VisitAllObjects(bot, searcher, ENGAGEMENT_RANGE);

    for (Unit* target : targets) {
        if (!IsValidTarget(target))
            continue;

        float dist = bot->GetDistance(target);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestTarget = target;
        }
    }

    return nearestTarget;
}

bool WarriorFuryStrategy::IsValidTarget(Unit* target) const {
    return target &&
           !target->IsDead() &&
           target->IsInWorld() &&
           target->IsHostileTo(ai->GetBot());
}

uint32 WarriorFuryStrategy::GetNextAbility(BotAI* ai) const {
    Player* bot = ai->GetBot();
    Unit* target = ai->GetCurrentTarget();

    if (!bot || !target)
        return 0;

    // Build priority rotation
    std::vector<AbilityPriority> rotation = BuildRotation(ai);

    // Sort by priority (highest first)
    std::sort(rotation.begin(), rotation.end(),
        [](const AbilityPriority& a, const AbilityPriority& b) {
            return a.priority > b.priority;
        });

    // Execute highest priority available ability
    for (const auto& ability : rotation) {
        if (ability.condition(ai) && IsSpellReady(bot, ability.spellId)) {
            return ability.spellId;
        }
    }

    return 0;
}

std::vector<WarriorFuryStrategy::AbilityPriority> WarriorFuryStrategy::BuildRotation(BotAI* ai) const {
    std::vector<AbilityPriority> rotation;

    // Primary ability - highest priority
    rotation.push_back({
        Spells::PRIMARY_ABILITY,
        1,
        [](BotAI* ai) -> bool {
            return true;  // Always available
        }
    });
    // Secondary ability - high priority
    rotation.push_back({
        Spells::SECONDARY_ABILITY,
        0.8,
        [](BotAI* ai) -> bool {
            return IsSpellReady(ai-&gt;GetBot(), Spells::SECONDARY_ABILITY);
        }
    });

    return rotation;
}

bool WarriorFuryStrategy::ShouldUseDefensiveCooldown(BotAI* ai) const {
    Player* bot = ai->GetBot();
    return bot->HealthBelowPct(30);
}

bool WarriorFuryStrategy::ShouldUseOffensiveCooldown(BotAI* ai) const {
    Unit* target = ai->GetCurrentTarget();
    if (!target)
        return false;

    // DPS use cooldowns on bosses or when target > 80% health
    return target->GetHealthPct() > 80.0f || target->IsWorldBoss();
}

// Helper method implementations
bool WarriorFuryStrategy::HasEnoughMana(Player* bot, uint32 spellId) const {
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    return bot->GetPower(POWER_MANA) >= spellInfo->CalcPowerCost(bot, spellInfo->GetSchoolMask());
}

bool WarriorFuryStrategy::IsSpellReady(Player* bot, uint32 spellId) const {
    return bot->HasSpell(spellId) &&
           !bot->HasSpellCooldown(spellId) &&
           HasEnoughMana(bot, spellId);
}

float WarriorFuryStrategy::CalculateThreat(Unit* target) const {
    // Simplified threat calculation
    return target->GetThreat(ai->GetBot());
}



uint32 WarriorFuryStrategy::GetRotationSpell(BotAI* ai) const {
    // Delegate to GetNextAbility for DPS rotation
    return GetNextAbility(ai);
}

bool WarriorFuryStrategy::ShouldUseCooldown(BotAI* ai) const {
    return ShouldUseOffensiveCooldown(ai);
}

float WarriorFuryStrategy::CalculateDPS(BotAI* ai) const {
    // Simplified DPS calculation
    Player* bot = ai->GetBot();
    if (!bot)
        return 0.0f;

    // Estimate based on attack power and spell power
    float ap = bot->GetTotalAttackPowerValue(BASE_ATTACK);
    float sp = bot->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL);

    return (ap + sp) / 10.0f; // Simplified estimation
}

} // namespace Playerbot::AI

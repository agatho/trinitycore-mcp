/**
 * PaladinProtectionStrategy - Protection Paladin tanking strategy with threat management
 *
 * Auto-generated by TrinityCore MCP Server
 * Generation date: 2025-11-01T10:01:47.736Z
 * Template: combat_strategy.hbs
 *
 * Thread-safety: Thread-safe (uses SpellPacketBuilder)
 * Performance target: &lt;0.1% CPU per bot
 */

#pragma once

#include "AI/BotAI.h"
#include "AI/Strategies/CombatStrategy.h"
#include "Entities/Unit/Unit.h"
#include "Packets/SpellPacketBuilder.h"

#include <atomic>
#include <mutex>

namespace Playerbot::AI {

/**
 * PaladinProtectionStrategy
 * Protection Paladin tanking strategy with threat management
 *
 * Role: tank
 * Engagement Range: 8m
 * Update Frequency: 100ms
 */
class PaladinProtectionStrategy : public CombatStrategy {
public:
    PaladinProtectionStrategy();
    virtual ~PaladinProtectionStrategy() = default;

    // Core strategy interface
    void Update(BotAI* ai, uint32 diff) override;
    bool ShouldEngage(Unit* target) const override;
    float GetEngagementRange() const override { return 8f; }

    // Target selection
    Unit* SelectTarget(BotAI* ai) const override;
    bool IsValidTarget(Unit* target) const override;

    // Ability management
    uint32 GetNextAbility(BotAI* ai) const override;
    bool ShouldUseDefensiveCooldown(BotAI* ai) const override;
    bool ShouldUseOffensiveCooldown(BotAI* ai) const override;

    // Role-specific methods
    void ManageThreat(BotAI* ai, Unit* target) const;
    bool NeedThreatBoost(BotAI* ai) const;
    uint32 GetThreatSpell() const;

private:
    // Helper methods
    bool HasEnoughMana(Player* bot, uint32 spellId) const;
    bool IsSpellReady(Player* bot, uint32 spellId) const;
    float CalculateThreat(Unit* target) const;

    // Priority calculation
    struct AbilityPriority {
        uint32 spellId;
        float priority;
        std::function<bool(BotAI*)> condition;
    };

    std::vector<AbilityPriority> BuildRotation(BotAI* ai) const;

    // Thread safety
    mutable std::mutex m_mutex;
    std::atomic<uint32> m_lastUpdate{0};

    // Configuration
    static constexpr float ENGAGEMENT_RANGE = 8f;
    static constexpr uint32 UPDATE_INTERVAL = 100;

    // Spell IDs
    enum Spells {
        PRIMARY_ABILITY = 0,
        SECONDARY_ABILITY = 0,
        COOLDOWN_ABILITY = 0,
        THREAT_GENERATOR = 0,
    };
};

} // namespace Playerbot::AI

// Implementation
namespace Playerbot::AI {

PaladinProtectionStrategy::PaladinProtectionStrategy() {
    // Initialize strategy
}

void PaladinProtectionStrategy::Update(BotAI* ai, uint32 diff) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_lastUpdate = WorldGameTime::GetGameTime();

    Player* bot = ai->GetBot();
    if (!bot || !bot->IsInCombat())
        return;

    // Get current target
    Unit* target = ai->GetCurrentTarget();
    if (!target || !IsValidTarget(target)) {
        target = SelectTarget(ai);
        if (target)
            ai->SetCurrentTarget(target);
    }

    if (!target)
        return;


    // Tank logic: manage threat
    ManageThreat(ai, target);

    if (NeedThreatBoost(ai)) {
        uint32 threatSpell = GetThreatSpell();
        if (threatSpell && IsSpellReady(bot, threatSpell)) {
            SpellPacketBuilder builder;
            builder.CastSpell(bot, threatSpell, target);
        }
    }


    // Execute combat rotation
    uint32 abilityId = GetNextAbility(ai);
    if (abilityId && IsSpellReady(bot, abilityId)) {
        SpellPacketBuilder builder;
        builder.CastSpell(bot, abilityId, target);
    }

    // Check for defensive cooldowns
    if (ShouldUseDefensiveCooldown(ai)) {
        // Use defensive abilities if health < 30%
        if (bot->HealthBelowPct(30)) {
            // Implement defensive cooldown logic
        }
    }
}

bool PaladinProtectionStrategy::ShouldEngage(Unit* target) const {
    if (!target || target->IsDead())
        return false;

    // Tanks engage aggressively
    return target->IsHostileTo(ai->GetBot()) &&
           target->IsWithinDistInMap(ai->GetBot(), ENGAGEMENT_RANGE);
}

Unit* PaladinProtectionStrategy::SelectTarget(BotAI* ai) const {
    Player* bot = ai->GetBot();

    // Prioritize current target
    if (Unit* current = ai->GetCurrentTarget())
        if (IsValidTarget(current))
            return current;

    // Tanks prioritize highest threat target
    Unit* highestThreat = nullptr;
    float maxThreat = 0.0f;

    std::list<Unit*> targets;
    Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(bot, ENGAGEMENT_RANGE);
    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, check);
    Cell::VisitAllObjects(bot, searcher, ENGAGEMENT_RANGE);

    for (Unit* target : targets) {
        if (!IsValidTarget(target))
            continue;

        float threat = CalculateThreat(target);
        if (threat > maxThreat) {
            maxThreat = threat;
            highestThreat = target;
        }
    }

    return highestThreat;
}

bool PaladinProtectionStrategy::IsValidTarget(Unit* target) const {
    return target &&
           !target->IsDead() &&
           target->IsInWorld() &&
           target->IsHostileTo(ai->GetBot());
}

uint32 PaladinProtectionStrategy::GetNextAbility(BotAI* ai) const {
    Player* bot = ai->GetBot();
    Unit* target = ai->GetCurrentTarget();

    if (!bot || !target)
        return 0;

    // Build priority rotation
    std::vector<AbilityPriority> rotation = BuildRotation(ai);

    // Sort by priority (highest first)
    std::sort(rotation.begin(), rotation.end(),
        [](const AbilityPriority& a, const AbilityPriority& b) {
            return a.priority > b.priority;
        });

    // Execute highest priority available ability
    for (const auto& ability : rotation) {
        if (ability.condition(ai) && IsSpellReady(bot, ability.spellId)) {
            return ability.spellId;
        }
    }

    return 0;
}

std::vector<PaladinProtectionStrategy::AbilityPriority> PaladinProtectionStrategy::BuildRotation(BotAI* ai) const {
    std::vector<AbilityPriority> rotation;

    // Primary ability - highest priority
    rotation.push_back({
        Spells::PRIMARY_ABILITY,
        1,
        [](BotAI* ai) -> bool {
            return true;  // Always available
        }
    });
    // Secondary ability - high priority
    rotation.push_back({
        Spells::SECONDARY_ABILITY,
        0.8,
        [](BotAI* ai) -> bool {
            return IsSpellReady(ai-&gt;GetBot(), Spells::SECONDARY_ABILITY);
        }
    });

    return rotation;
}

bool PaladinProtectionStrategy::ShouldUseDefensiveCooldown(BotAI* ai) const {
    Player* bot = ai->GetBot();
    return bot->HealthBelowPct(30);
}

bool PaladinProtectionStrategy::ShouldUseOffensiveCooldown(BotAI* ai) const {
    Unit* target = ai->GetCurrentTarget();
    if (!target)
        return false;

    // Tanks use offensive cooldowns for threat
    return NeedThreatBoost(ai);
}

// Helper method implementations
bool PaladinProtectionStrategy::HasEnoughMana(Player* bot, uint32 spellId) const {
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    return bot->GetPower(POWER_MANA) >= spellInfo->CalcPowerCost(bot, spellInfo->GetSchoolMask());
}

bool PaladinProtectionStrategy::IsSpellReady(Player* bot, uint32 spellId) const {
    return bot->HasSpell(spellId) &&
           !bot->HasSpellCooldown(spellId) &&
           HasEnoughMana(bot, spellId);
}

float PaladinProtectionStrategy::CalculateThreat(Unit* target) const {
    // Simplified threat calculation
    return target->GetThreat(ai->GetBot());
}


void PaladinProtectionStrategy::ManageThreat(BotAI* ai, Unit* target) const {
    // Implement tank-specific threat management
    if (NeedThreatBoost(ai)) {
        uint32 threatSpell = GetThreatSpell();
        // Threat spell will be cast in Update()
    }
}

bool PaladinProtectionStrategy::NeedThreatBoost(BotAI* ai) const {
    Unit* target = ai->GetCurrentTarget();
    if (!target)
        return false;

    // Check if we're losing threat
    float ourThreat = target->GetThreat(ai->GetBot());
    float maxThreat = 0.0f;

    // Find highest threat from other targets
    for (auto& threatRef : target->GetThreatManager().GetThreatList()) {
        if (threatRef->GetVictim() != ai->GetBot()) {
            maxThreat = std::max(maxThreat, threatRef->GetThreat());
        }
    }

    // Need threat boost if someone else has 90%+ of our threat
    return maxThreat > (ourThreat * 0.9f);
}

uint32 PaladinProtectionStrategy::GetThreatSpell() const {
    return Spells::THREAT_GENERATOR;
}


} // namespace Playerbot::AI

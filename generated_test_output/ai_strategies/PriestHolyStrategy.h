/**
 * PriestHolyStrategy - Holy Priest healing strategy with mana management
 *
 * Auto-generated by TrinityCore MCP Server
 * Generation date: 2025-11-01T10:01:47.737Z
 * Template: combat_strategy.hbs
 *
 * Thread-safety: Thread-safe (uses SpellPacketBuilder)
 * Performance target: &lt;0.1% CPU per bot
 */

#pragma once

#include "AI/BotAI.h"
#include "AI/Strategies/CombatStrategy.h"
#include "Entities/Unit/Unit.h"
#include "Packets/SpellPacketBuilder.h"

#include <atomic>
#include <mutex>

namespace Playerbot::AI {

/**
 * PriestHolyStrategy
 * Holy Priest healing strategy with mana management
 *
 * Role: healer
 * Engagement Range: 40m
 * Update Frequency: 100ms
 */
class PriestHolyStrategy : public CombatStrategy {
public:
    PriestHolyStrategy();
    virtual ~PriestHolyStrategy() = default;

    // Core strategy interface
    void Update(BotAI* ai, uint32 diff) override;
    bool ShouldEngage(Unit* target) const override;
    float GetEngagementRange() const override { return 40f; }

    // Target selection
    Unit* SelectTarget(BotAI* ai) const override;
    bool IsValidTarget(Unit* target) const override;

    // Ability management
    uint32 GetNextAbility(BotAI* ai) const override;
    bool ShouldUseDefensiveCooldown(BotAI* ai) const override;
    bool ShouldUseOffensiveCooldown(BotAI* ai) const override;

    // Role-specific methods
    Unit* SelectHealTarget(BotAI* ai) const;
    bool NeedEmergencyHeal(Unit* target) const;
    uint32 GetHealSpell(Unit* target) const;

private:
    // Helper methods
    bool HasEnoughMana(Player* bot, uint32 spellId) const;
    bool IsSpellReady(Player* bot, uint32 spellId) const;
    float CalculateThreat(Unit* target) const;

    // Priority calculation
    struct AbilityPriority {
        uint32 spellId;
        float priority;
        std::function<bool(BotAI*)> condition;
    };

    std::vector<AbilityPriority> BuildRotation(BotAI* ai) const;

    // Thread safety
    mutable std::mutex m_mutex;
    std::atomic<uint32> m_lastUpdate{0};

    // Configuration
    static constexpr float ENGAGEMENT_RANGE = 40f;
    static constexpr uint32 UPDATE_INTERVAL = 100;

    // Spell IDs
    enum Spells {
        PRIMARY_ABILITY = 0,
        SECONDARY_ABILITY = 0,
        COOLDOWN_ABILITY = 0,
        EMERGENCY_HEAL = 0,
        EFFICIENT_HEAL = 0,
    };
};

} // namespace Playerbot::AI

// Implementation
namespace Playerbot::AI {

PriestHolyStrategy::PriestHolyStrategy() {
    // Initialize strategy
}

void PriestHolyStrategy::Update(BotAI* ai, uint32 diff) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_lastUpdate = WorldGameTime::GetGameTime();

    Player* bot = ai->GetBot();
    if (!bot || !bot->IsInCombat())
        return;

    // Get current target
    Unit* target = ai->GetCurrentTarget();
    if (!target || !IsValidTarget(target)) {
        target = SelectTarget(ai);
        if (target)
            ai->SetCurrentTarget(target);
    }

    if (!target)
        return;

    // Healer logic: prioritize healing over damage
    Unit* healTarget = SelectHealTarget(ai);
    if (healTarget && NeedEmergencyHeal(healTarget)) {
        uint32 healSpell = GetHealSpell(healTarget);
        if (healSpell && IsSpellReady(bot, healSpell)) {
            SpellPacketBuilder builder;
            builder.CastSpell(bot, healSpell, healTarget);
            return;
        }
    }



    // Execute combat rotation
    uint32 abilityId = GetNextAbility(ai);
    if (abilityId && IsSpellReady(bot, abilityId)) {
        SpellPacketBuilder builder;
        builder.CastSpell(bot, abilityId, target);
    }

    // Check for defensive cooldowns
    if (ShouldUseDefensiveCooldown(ai)) {
        // Use defensive abilities if health < 30%
        if (bot->HealthBelowPct(30)) {
            // Implement defensive cooldown logic
        }
    }
}

bool PriestHolyStrategy::ShouldEngage(Unit* target) const {
    if (!target || target->IsDead())
        return false;

    // Healers engage conservatively
    return false; // Focus on healing
}

Unit* PriestHolyStrategy::SelectTarget(BotAI* ai) const {
    Player* bot = ai->GetBot();

    // Prioritize current target
    if (Unit* current = ai->GetCurrentTarget())
        if (IsValidTarget(current))
            return current;

    // Find nearest hostile target
    Unit* nearestTarget = nullptr;
    float nearestDist = 999999.0f;

    std::list<Unit*> targets;
    Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(bot, ENGAGEMENT_RANGE);
    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, check);
    Cell::VisitAllObjects(bot, searcher, ENGAGEMENT_RANGE);

    for (Unit* target : targets) {
        if (!IsValidTarget(target))
            continue;

        float dist = bot->GetDistance(target);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestTarget = target;
        }
    }

    return nearestTarget;
}

bool PriestHolyStrategy::IsValidTarget(Unit* target) const {
    return target &&
           !target->IsDead() &&
           target->IsInWorld() &&
           target->IsHostileTo(ai->GetBot());
}

uint32 PriestHolyStrategy::GetNextAbility(BotAI* ai) const {
    Player* bot = ai->GetBot();
    Unit* target = ai->GetCurrentTarget();

    if (!bot || !target)
        return 0;

    // Build priority rotation
    std::vector<AbilityPriority> rotation = BuildRotation(ai);

    // Sort by priority (highest first)
    std::sort(rotation.begin(), rotation.end(),
        [](const AbilityPriority& a, const AbilityPriority& b) {
            return a.priority > b.priority;
        });

    // Execute highest priority available ability
    for (const auto& ability : rotation) {
        if (ability.condition(ai) && IsSpellReady(bot, ability.spellId)) {
            return ability.spellId;
        }
    }

    return 0;
}

std::vector<PriestHolyStrategy::AbilityPriority> PriestHolyStrategy::BuildRotation(BotAI* ai) const {
    std::vector<AbilityPriority> rotation;

    // Primary ability - highest priority
    rotation.push_back({
        Spells::PRIMARY_ABILITY,
        1,
        [](BotAI* ai) -> bool {
            return true;  // Always available
        }
    });
    // Secondary ability - high priority
    rotation.push_back({
        Spells::SECONDARY_ABILITY,
        0.8,
        [](BotAI* ai) -> bool {
            return IsSpellReady(ai-&gt;GetBot(), Spells::SECONDARY_ABILITY);
        }
    });

    return rotation;
}

bool PriestHolyStrategy::ShouldUseDefensiveCooldown(BotAI* ai) const {
    Player* bot = ai->GetBot();
    return bot->HealthBelowPct(30);
}

bool PriestHolyStrategy::ShouldUseOffensiveCooldown(BotAI* ai) const {
    Unit* target = ai->GetCurrentTarget();
    if (!target)
        return false;

    return false;
}

// Helper method implementations
bool PriestHolyStrategy::HasEnoughMana(Player* bot, uint32 spellId) const {
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    return bot->GetPower(POWER_MANA) >= spellInfo->CalcPowerCost(bot, spellInfo->GetSchoolMask());
}

bool PriestHolyStrategy::IsSpellReady(Player* bot, uint32 spellId) const {
    return bot->HasSpell(spellId) &&
           !bot->HasSpellCooldown(spellId) &&
           HasEnoughMana(bot, spellId);
}

float PriestHolyStrategy::CalculateThreat(Unit* target) const {
    // Simplified threat calculation
    return target->GetThreat(ai->GetBot());
}

Unit* PriestHolyStrategy::SelectHealTarget(BotAI* ai) const {
    Player* bot = ai->GetBot();
    Unit* lowestHealth = nullptr;
    float lowestPct = 100.0f;

    // Check self first
    if (bot->HealthBelowPct(70)) {
        return bot;
    }

    // Check group members
    Group* group = bot->GetGroup();
    if (group) {
        for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next()) {
            Player* member = ref->GetSource();
            if (!member || !member->IsInWorld())
                continue;

            float healthPct = member->GetHealthPct();
            if (healthPct < lowestPct && member->IsWithinDistInMap(bot, 40.0f)) {
                lowestPct = healthPct;
                lowestHealth = member;
            }
        }
    }

    return lowestHealth;
}

bool PriestHolyStrategy::NeedEmergencyHeal(Unit* target) const {
    return target && target->HealthBelowPct(30);
}

uint32 PriestHolyStrategy::GetHealSpell(Unit* target) const {
    if (!target)
        return 0;

    if (NeedEmergencyHeal(target)) {
        // Use fast emergency heal
        return Spells::EMERGENCY_HEAL;
    } else if (target->HealthBelowPct(70)) {
        // Use efficient heal
        return Spells::EFFICIENT_HEAL;
    }

    return 0;
}



} // namespace Playerbot::AI

api:
  class: ObstacleAvoidanceManager
  method: CheckCapsuleCollision
  signature: bool ObstacleAvoidanceManager::CheckCapsuleCollision(const int & start,
    const int & end, float radius, const int & center, float obstacleRadius)
documentation:
  brief: Checks for collision between a capsule-shaped obstacle and a line segment
    representing movement path.
  description: The CheckCapsuleCollision method determines whether a capsule-shaped
    obstacle intersects with a line segment defined by two points. This is commonly
    used in AI pathfinding to detect potential collisions with environmental obstacles
    such as walls, furniture, or other objects. The method takes into account the
    radius of both the moving entity (represented by the line segment) and the obstacle
    itself. It's typically called during obstacle avoidance calculations within the
    TrinityCore framework to ensure NPCs and players navigate safely through the game
    world without clipping through solid objects.
  parameters:
  - name: start
    description: The starting point of the line segment representing the movement
      path, specified as an index into a coordinate array or similar data structure.
  - name: end
    description: The ending point of the line segment representing the movement path,
      specified as an index into a coordinate array or similar data structure.
  - name: radius
    description: The radius of the capsule shape representing the moving entity's
      collision bounds. Must be non-negative.
  - name: center
    description: The center point of the obstacle, specified as an index into a coordinate
      array or similar data structure.
  - name: obstacleRadius
    description: The radius of the capsule-shaped obstacle. Must be non-negative.
  returns: Returns true if the capsule-shaped moving entity collides with the obstacle;
    otherwise returns false.
  examples:
  - title: Basic collision check between two capsules
    code: bool isColliding = obstacleManager.CheckCapsuleCollision(0, 1, 0.5f, 2,
      1.0f); // Check if a moving entity with radius 0.5 collides with an obstacle
      at index 2 with radius 1.0
    language: cpp
  - title: Using in AI pathfinding to avoid obstacles
    code: "if (!obstacleManager.CheckCapsuleCollision(playerPositionIndex, targetPositionIndex,\
      \ playerRadius, obstacleIndex, obstacleRadius))\n{\n    // Proceed with movement\
      \ since no collision detected\n    MoveToTarget();\n}\nelse\n{\n    // Find\
      \ alternative path due to collision\n    FindAlternativePath();\n}"
    language: cpp
  notes: This method assumes that all indices provided are valid and point to existing
    coordinates in the underlying data structure. It performs a mathematical calculation
    involving vector projections and distance checks between line segments and capsules,
    which can be computationally intensive for large numbers of obstacles. The implementation
    likely uses optimized geometric algorithms for performance.
  warnings: Ensure that the start and end indices refer to valid points in your coordinate
    system; otherwise behavior is undefined. Also note that this function does not
    account for dynamic changes in obstacle positions during execution unless explicitly
    updated.
  related:
  - GetObstaclePosition
  - UpdateObstacle
  - CalculatePath
metadata:
  confidence: 0.85
  generated_at: '2025-11-07T01:22:55.812813'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

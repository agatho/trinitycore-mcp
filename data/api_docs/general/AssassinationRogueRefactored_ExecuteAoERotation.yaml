api:
  class: AssassinationRogueRefactored
  method: ExecuteAoERotation
  signature: void AssassinationRogueRefactored::ExecuteAoERotation(int * target, uint32
    enemyCount)
documentation:
  brief: Executes the assassination rogue's AoE rotation logic for a specified number
    of enemies
  description: The ExecuteAoERotation method implements the core logic for an assassination
    rogue's area-of-effect combat rotation. This method determines the optimal sequence
    of abilities and spells to cast against multiple targets within range, prioritizing
    high-damage abilities like Slice and Dice, Envenom, and Mutilate based on enemy
    count and combat conditions. The method takes into account the rogue's energy
    management, combo point generation, and target selection to maximize damage output
    in AoE scenarios. It is typically called during combat when multiple enemies are
    present and the rogue's rotation needs to be adjusted for group engagement.
  parameters:
  - name: target
    description: Pointer to an array of enemy targets. The method will process these
      targets according to the AoE rotation logic.
  - name: enemyCount
    description: The number of enemies in the target array that should be processed
      by the AoE rotation. Must be a positive integer representing valid combat targets.
  returns: null
  examples:
  - title: Basic AoE Rotation Execution
    code: 'int enemies[5] = {101, 102, 103, 104, 105};

      rogue->ExecuteAoERotation(enemies, 5);'
    language: cpp
  - title: Dynamic Enemy Count Handling
    code: "std::vector<int> targets = GetNearbyEnemies();\nif (!targets.empty()) {\n\
      \    rogue->ExecuteAoERotation(targets.data(), static_cast<uint32>(targets.size()));\n\
      }"
    language: cpp
  notes: This method assumes that the rogue is already in combat and has valid targets.
    The implementation may internally manage energy costs, combo point requirements,
    and spell cooldowns. It's recommended to call this method only when multiple enemies
    are present for optimal performance.
  warnings: Ensure that the target array contains valid enemy identifiers before calling
    this method. Passing an invalid or null pointer could lead to undefined behavior.
    The method does not validate the enemyCount parameter beyond checking for positive
    values, so passing a count larger than the actual array size may result in accessing
    invalid memory.
  related:
  - ExecuteSingleTargetRotation
  - GetAvailableAbilities
  - CheckEnergyRequirements
metadata:
  confidence: 0.85
  generated_at: '2025-11-09T10:36:01.005509'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

api:
  class: ObstacleAvoidanceManager
  method: GetCachedAvoidance
  signature: AvoidanceManeuver * ObstacleAvoidanceManager::GetCachedAvoidance(const
    std::string & key)
documentation:
  brief: Retrieves a cached avoidance maneuver by its key identifier.
  description: The GetCachedAvoidance method retrieves a previously stored AvoidanceManeuver
    object from an internal cache using the provided key. This method is typically
    used in AI pathfinding and obstacle avoidance systems within TrinityCore to efficiently
    manage and reuse computed avoidance behaviors. The method performs a lookup in
    the manager's internal cache structure, returning a pointer to the cached maneuver
    if found, or nullptr if no matching entry exists. This allows for performance
    optimization by avoiding recomputation of similar avoidance maneuvers.
  parameters:
  - name: key
    description: A unique string identifier used to look up the cached avoidance maneuver.
      This key should be consistent across calls to retrieve the same maneuver.
  returns: A pointer to the AvoidanceManeuver object if found in the cache, or nullptr
    if no matching entry exists for the given key.
  examples:
  - title: Basic Usage Example
    code: "AvoidanceManeuver* maneuver = obstacleAvoidanceManager->GetCachedAvoidance(\"\
      avoidance_001\");\nif (maneuver != nullptr)\n{\n    // Use the cached avoidance\
      \ maneuver\n    maneuver->Execute();\n}"
    language: cpp
  - title: Safe Usage with Null Check
    code: "std::string key = \"player_obstacle_avoidance\";\nAvoidanceManeuver* cachedManeuver\
      \ = obstacleAvoidanceManager->GetCachedAvoidance(key);\nif (cachedManeuver !=\
      \ nullptr)\n{\n    // Proceed with using the cached maneuver\n    player->SetAvoidanceManeuver(cachedManeuver);\n\
      }\nelse\n{\n    // Handle case where no cached maneuver exists\n    // Possibly\
      \ compute and cache a new one\n}"
    language: cpp
  notes: This method assumes that the internal cache is thread-safe or that access
    is properly synchronized by the caller. The returned pointer should not be deleted
    directly, as it's managed by the ObstacleAvoidanceManager. Cache entries may be
    evicted based on internal policies such as LRU (Least Recently Used) or time-based
    expiration.
  warnings: Ensure that the key passed to this method is consistent with how it was
    originally stored in the cache. Improper key usage can lead to incorrect avoidance
    behavior or null pointer dereferences if not handled properly.
  related:
  - CacheAvoidance
  - ClearCachedAvoidances
  - IsCached
metadata:
  confidence: 0.9
  generated_at: '2025-11-06T07:21:52.116915'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

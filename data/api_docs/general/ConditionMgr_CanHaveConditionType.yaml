api:
  class: ConditionMgr
  method: CanHaveConditionType
  signature: bool ConditionMgr::CanHaveConditionType(ConditionSourceType sourceType,
    ConditionTypes conditionType)
documentation:
  brief: Determines whether a given condition type is valid for a specified source
    type in the condition management system.
  description: The CanHaveConditionType method checks if a specific ConditionTypes
    value can be used with a given ConditionSourceType. This validation ensures that
    conditions are applied correctly according to their intended use within the TrinityCore
    framework. The method performs internal lookups against predefined rules that
    govern which types of conditions are allowed for different source types such as
    quests, items, creatures, game objects, and more. It's primarily used during condition
    loading and validation phases to prevent invalid condition configurations from
    being processed further.
  parameters:
  - name: sourceType
    description: The type of source entity that the condition applies to. Valid values
      include various ConditionSourceType enumerators such as SOURCE_TYPE_QUEST_START,
      SOURCE_TYPE_QUEST_END, SOURCE_TYPE_CREATURE_GOSSIP, etc.
  - name: conditionType
    description: The type of condition being evaluated. This should be one of the
      ConditionTypes enumeration values like CONDITION_NONE, CONDITION_AURA, CONDITION_ITEM,
      CONDITION_DEAD, etc.
  returns: Returns true if the specified condition type is valid for the given source
    type; otherwise returns false. A return value of false indicates that the combination
    of source and condition types is not supported by the system.
  examples:
  - title: Checking Condition Validity for Quest Start
    code: "if (sConditionMgr->CanHaveConditionType(SOURCE_TYPE_QUEST_START, CONDITION_AURA))\
      \ {\n    // This condition type is valid for quest start sources\n    printf(\"\
      Aura condition allowed for quest start\\n\");\n} else {\n    printf(\"Aura condition\
      \ not allowed for quest start\\n\");\n}"
    language: cpp
  - title: Validating Multiple Condition Types
    code: "ConditionSourceType source = SOURCE_TYPE_CREATURE_GOSSIP;\nConditionTypes\
      \ conditions[] = { CONDITION_AURA, CONDITION_ITEM, CONDITION_REPUTATION_RANK\
      \ };\n\nfor (auto cond : conditions) {\n    if (sConditionMgr->CanHaveConditionType(source,\
      \ cond)) {\n        printf(\"Condition %d is valid for gossip\\n\", cond);\n\
      \    } else {\n        printf(\"Condition %d is NOT valid for gossip\\n\", cond);\n\
      \    }\n}"
    language: cpp
  notes: This method relies on internal lookup tables that define valid combinations
    between source types and condition types. The implementation may involve static
    data structures or runtime lookups depending on how the condition system is designed
    in TrinityCore. Developers should not assume all combinations are valid without
    checking with this method first.
  warnings: Do not use this method to validate user input directly without proper
    sanitization, as invalid source or condition types could cause undefined behavior
    if not properly handled by the calling code.
  related:
  - GetConditionList
  - AddCondition
  - RemoveCondition
metadata:
  confidence: 0.9
  generated_at: '2025-11-01T16:03:49.413445'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

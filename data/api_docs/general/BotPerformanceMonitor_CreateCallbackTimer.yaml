api:
  class: BotPerformanceMonitor
  method: CreateCallbackTimer
  signature: ScopedTimer BotPerformanceMonitor::CreateCallbackTimer()
documentation:
  brief: Creates and returns a scoped timer for monitoring callback performance.
  description: The CreateCallbackTimer method initializes and returns a ScopedTimer
    object that can be used to measure the execution time of callback functions within
    the BotPerformanceMonitor. This timer is typically used to track how long specific
    bot behaviors or AI decisions take to execute, which helps in identifying performance
    bottlenecks. The returned ScopedTimer automatically starts measuring time upon
    creation and will stop when it goes out of scope, making it ideal for RAII-style
    timing measurements. This method is essential for profiling bot behavior and ensuring
    optimal performance in TrinityCore environments.
  parameters: []
  returns: A ScopedTimer object that begins timing immediately upon construction and
    automatically stops when it goes out of scope. The timer can be used to measure
    execution duration of callback functions or code blocks.
  examples:
  - title: Basic Timer Usage
    code: "void MyBot::ProcessAI()\n{\n    auto timer = botPerformanceMonitor.CreateCallbackTimer();\n\
      \    // Perform AI logic here\n    DoComplexCalculation();\n    // Timer automatically\
      \ stops and reports duration when 'timer' goes out of scope\n}"
    language: cpp
  - title: Measuring Multiple Callbacks
    code: "void MyBot::ProcessMultipleCallbacks()\n{\n    {\n        auto timer1 =\
      \ botPerformanceMonitor.CreateCallbackTimer();\n        ProcessMovement();\n\
      \    }\n    {\n        auto timer2 = botPerformanceMonitor.CreateCallbackTimer();\n\
      \        ProcessCombat();\n    }\n    // Each timer will report individual execution\
      \ times\n}"
    language: cpp
  notes: The ScopedTimer returned by this method follows RAII principles, meaning
    it automatically manages timing start and stop operations. The timer is designed
    to work in a multi-threaded environment where each thread gets its own timing
    measurement. Performance monitoring should be enabled only during development
    or debugging phases as it may introduce minimal overhead.
  warnings: Avoid creating multiple timers simultaneously without proper scoping as
    this can lead to confusion about which measurements are being recorded. The timer's
    accuracy depends on the system's high-resolution performance counter, so results
    may vary slightly across different hardware configurations.
  related:
  - BotPerformanceMonitor::GetTimer
  - BotPerformanceMonitor::StartTimer
  - BotPerformanceMonitor::StopTimer
metadata:
  confidence: 0.92
  generated_at: '2025-11-02T11:22:36.744108'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

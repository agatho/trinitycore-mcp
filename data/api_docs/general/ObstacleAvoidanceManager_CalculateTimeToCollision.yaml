api:
  class: ObstacleAvoidanceManager
  method: CalculateTimeToCollision
  signature: float ObstacleAvoidanceManager::CalculateTimeToCollision(const ObstacleInfo
    & obstacle, const DetectionContext & context)
documentation:
  brief: Calculates the time until collision with a given obstacle based on current
    movement context.
  description: The CalculateTimeToCollision method determines how long it will take
    for an entity to collide with a specified obstacle, using the provided detection
    context. This method is typically used in AI pathfinding and obstacle avoidance
    systems within TrinityCore's movement engine. It evaluates the relative positions,
    velocities, and movement directions of the entity and the obstacle to compute
    a time-to-collision value. The result can be used to adjust movement behavior,
    such as slowing down or changing direction to avoid collisions. This method assumes
    that both the entity and the obstacle are moving in a predictable manner and does
    not account for sudden changes in trajectory.
  parameters:
  - name: obstacle
    description: Reference to an ObstacleInfo structure containing details about the
      obstacle, including its position, size, and movement vector.
  - name: context
    description: Reference to a DetectionContext structure that provides contextual
      information about the entity's current state, such as position, velocity, and
      movement direction.
  returns: A float value representing the time (in seconds) until collision occurs.
    Returns 0.0f if no collision is expected or if parameters are invalid.
  examples:
  - title: Basic usage in AI movement
    code: "float timeToCollision = obstacleAvoidanceManager.CalculateTimeToCollision(obstacleInfo,\
      \ detectionContext);\nif (timeToCollision > 0.0f && timeToCollision < 2.0f)\
      \ {\n    // Adjust movement to avoid collision\n    entity->SetSpeed(MOVE_RUN,\
      \ 0.5f);\n}"
    language: cpp
  - title: Using with obstacle avoidance logic
    code: "ObstacleInfo obstacle;\nDetectionContext context;\n// ... populate obstacle\
      \ and context ...\nfloat collisionTime = manager.CalculateTimeToCollision(obstacle,\
      \ context);\nif (collisionTime > 0.0f && collisionTime < 1.0f) {\n    // Plan\
      \ alternative path\n    PathFinder pathFinder;\n    pathFinder.SetAvoidance(true);\n\
      \    pathFinder.CalculatePath(destination);\n}"
    language: cpp
  notes: This method performs calculations based on linear motion models and does
    not consider complex physics or dynamic obstacles. It is designed for real-time
    performance in game AI systems, so it may use simplified collision detection algorithms.
    The accuracy of the result depends heavily on the precision of the input data
    provided in both ObstacleInfo and DetectionContext structures.
  warnings: This method assumes constant velocity motion models. If either the entity
    or obstacle changes direction suddenly, the calculated time to collision may become
    inaccurate. Additionally, this method does not account for obstacles that are
    moving in non-linear paths or have complex shapes beyond basic bounding volumes.
  related:
  - GetObstacleInfo
  - UpdateDetectionContext
  - IsCollisionImminent
metadata:
  confidence: 0.85
  generated_at: '2025-11-02T02:30:17.905853'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

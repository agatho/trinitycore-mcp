api:
  class: ObstacleAvoidanceManager
  method: CalculateClosestApproach
  signature: float ObstacleAvoidanceManager::CalculateClosestApproach(const int &
    pos1, const int & vel1, const int & pos2, const int & vel2)
documentation:
  brief: Calculates the closest approach distance between two moving obstacles using
    their positions and velocities.
  description: The CalculateClosestApproach method computes the minimum distance that
    will occur between two moving obstacles, represented by their current positions
    and velocity vectors. This is commonly used in pathfinding and AI behavior to
    predict potential collisions or determine safe distances between entities. The
    method assumes both obstacles are moving in straight lines at constant speeds
    and directions. It returns a float value representing the closest approach distance
    in game units. The calculation considers the relative motion of both obstacles
    and can be used to make decisions about avoidance maneuvers or path adjustments.
  parameters:
  - name: pos1
    description: The current position of the first obstacle as an integer coordinate
  - name: vel1
    description: The velocity vector of the first obstacle as an integer value representing
      speed and direction
  - name: pos2
    description: The current position of the second obstacle as an integer coordinate
  - name: vel2
    description: The velocity vector of the second obstacle as an integer value representing
      speed and direction
  returns: A float value representing the minimum distance between the two obstacles
    during their movement. Returns 0.0f if the obstacles are currently overlapping
    or will collide immediately.
  examples:
  - title: Basic obstacle avoidance calculation
    code: 'ObstacleAvoidanceManager manager;

      int pos1 = 100, vel1 = 50;

      int pos2 = 150, vel2 = -30;

      float closest = manager.CalculateClosestApproach(pos1, vel1, pos2, vel2);

      // Returns the minimum distance between two moving obstacles'
    language: cpp
  - title: Using result for avoidance decision
    code: "ObstacleAvoidanceManager manager;\nint playerPos = player->GetPositionX();\n\
      int playerVel = player->GetSpeed();\nint npcPos = npc->GetPositionX();\nint\
      \ npcVel = npc->GetSpeed();\nfloat distance = manager.CalculateClosestApproach(playerPos,\
      \ playerVel, npcPos, npcVel);\nif (distance < 10.0f) {\n    // Initiate avoidance\
      \ behavior\n    player->SetMovementType(MOVE_TYPE_AVOID_OBSTACLE);\n}"
    language: cpp
  notes: This method performs a mathematical calculation based on linear motion and
    assumes constant velocities. It's designed for use in AI pathfinding systems where
    precise collision prediction is needed. The integer parameters are typically converted
    to floating point values internally for the calculation, so precision may be lost
    if values are too large or small. Performance is generally good for single calculations
    but should be used judiciously in tight loops.
  warnings: This method assumes linear motion and constant velocities. It will not
    account for acceleration, deceleration, or complex movement patterns. The integer
    parameters should represent meaningful coordinates within the game world's coordinate
    system. If positions or velocities are invalid (e.g., extremely large values),
    unexpected results may occur. This function does not consider obstacle size or
    shape beyond their position and velocity vectors.
  related:
  - CalculateAvoidancePath
  - GetObstacleDistance
  - IsCollisionImminent
metadata:
  confidence: 0.85
  generated_at: '2025-11-07T01:23:59.901958'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

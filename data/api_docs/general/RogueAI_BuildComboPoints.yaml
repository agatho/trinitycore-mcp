api:
  class: RogueAI
  method: BuildComboPoints
  signature: bool RogueAI::BuildComboPoints(int * target)
documentation:
  brief: Attempts to build combo points for the rogue AI by evaluating the current
    target and available abilities.
  description: The BuildComboPoints method is responsible for determining whether
    the rogue AI can generate combo points on its current target. It evaluates the
    target's status, the rogue's available abilities, and the current combo point
    count to decide if a combo point can be generated. This method typically checks
    for valid attack conditions, such as whether the target is within range and not
    immune to combo point generation effects. The method returns true if combo points
    were successfully built or if no further action is required; otherwise, it returns
    false to indicate that the AI should consider alternative actions.
  parameters:
  - name: target
    description: Pointer to an integer representing the target's ID or index. This
      parameter specifies which entity the rogue AI should attempt to build combo
      points against.
  returns: Returns true if combo points were successfully built or no further action
    is needed, false otherwise. A return value of false may indicate that the target
    is invalid, out of range, or immune to combo point generation.
  examples:
  - title: Basic usage in rogue AI logic
    code: "int targetId = 42;\nif (rogueAI->BuildComboPoints(&targetId)) {\n    //\
      \ Combo points built successfully\n    printf(\"Combo points updated for target\
      \ %d\\n\", targetId);\n} else {\n    // Failed to build combo points\n    printf(\"\
      Failed to build combo points for target %d\\n\", targetId);\n}"
    language: cpp
  - title: Integration with combat state management
    code: "class RogueAI {\npublic:\n    bool BuildComboPoints(int* target) {\n  \
      \      if (!target || *target <= 0) return false;\n        \n        // Simulate\
      \ checking if target is valid and in range\n        Unit* unit = ObjectAccessor::GetUnit(*target);\n\
      \        if (!unit || !unit->IsInWorld() || unit->IsDead()) {\n            return\
      \ false;\n        }\n        \n        // Simulate combo point generation logic\n\
      \        if (CanGenerateComboPoints(unit)) {\n            GenerateComboPoints();\n\
      \            return true;\n        }\n        \n        return false;\n    }\n\
      private:\n    bool CanGenerateComboPoints(Unit* target) {\n        return target\
      \ && target->IsInWorld() && !target->IsDead() && IsWithinRange(target);\n  \
      \  }\n    void GenerateComboPoints() { /* Implementation */ }\n    bool IsWithinRange(Unit*\
      \ target) { /* Implementation */ }\n};"
    language: cpp
  notes: This method is part of the rogue AI's core decision-making loop and should
    be called frequently during combat to maintain up-to-date combo point information.
    It assumes that the target pointer points to a valid unit in the game world and
    does not perform any validation on the target itself beyond basic existence checks.
  warnings: Do not pass null or invalid pointers to this method as it may lead to
    undefined behavior. The target must be a valid unit that exists within the game
    world for this method to function correctly.
  related:
  - GetComboPoints
  - ResetComboPoints
  - CanGenerateComboPoints
metadata:
  confidence: 0.85
  generated_at: '2025-11-09T11:16:09.772875'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

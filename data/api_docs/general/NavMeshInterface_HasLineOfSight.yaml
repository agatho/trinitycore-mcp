api:
  class: NavMeshInterface
  method: HasLineOfSight
  signature: bool NavMeshInterface::HasLineOfSight(Map * map, const int & start, const
    int & end) const
documentation:
  brief: Determines whether there is a clear line of sight between two points in a
    map using navigation mesh data.
  description: The HasLineOfSight method checks if a direct visual or physical path
    exists between two specified points within a given map's navigation mesh. This
    functionality is essential for determining whether entities such as players, NPCs,
    or projectiles can see each other without obstruction. The method uses the underlying
    NavMesh data structure to perform efficient spatial queries and returns true if
    no obstacles block the line of sight, false otherwise. It is commonly used in
    AI pathfinding, spell casting mechanics, and visibility calculations within the
    game world.
  parameters:
  - name: map
    description: Pointer to the Map object where the line of sight check will be performed.
      Must not be null.
  - name: start
    description: Integer identifier representing the starting point for the line of
      sight test. Typically corresponds to a node or position in the navigation mesh.
  - name: end
    description: Integer identifier representing the ending point for the line of
      sight test. Must correspond to a valid node or position in the same map's navigation
      mesh.
  returns: Returns true if there is an unobstructed line of sight between the start
    and end points, false if any obstacle blocks the path.
  examples:
  - title: Basic Line of Sight Check
    code: "Map* map = player->GetMap();\nint startNode = 100;\nint endNode = 200;\n\
      bool hasLOS = NavMeshInterface::HasLineOfSight(map, startNode, endNode);\nif\
      \ (hasLOS)\n{\n    // Perform action when line of sight is clear\n}"
    language: cpp
  - title: Using Line of Sight in AI Decision Making
    code: "class EnemyAI {\npublic:\n    void Update()\n    {\n        if (NavMeshInterface::HasLineOfSight(m_map,\
      \ m_currentNode, m_targetNode))\n        {\n            // Enemy can see target\
      \ and may attack\n            AttackTarget();\n        }\n        else\n   \
      \     {\n            // No direct line of sight, consider alternative actions\n\
      \            FindAlternativePath();\n        }\n    }\n};"
    language: cpp
  notes: This method relies on precomputed navigation mesh data and assumes that the
    provided node identifiers are valid within the context of the given map. Performance
    is optimized through spatial indexing, but frequent calls may impact frame rate
    if not used judiciously.
  warnings: Ensure that the map pointer is valid and that both start and end nodes
    exist in the same map's navigation mesh; otherwise behavior is undefined. Avoid
    calling this method excessively in tight loops without caching results.
  related:
  - GetNavMesh
  - FindPath
  - IsInLineOfSight
metadata:
  confidence: 0.9
  generated_at: '2025-11-03T23:00:21.830626'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

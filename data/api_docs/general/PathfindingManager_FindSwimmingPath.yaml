api:
  class: PathfindingManager
  method: FindSwimmingPath
  signature: PathResult PathfindingManager::FindSwimmingPath(const int & start, const
    int & goal)
documentation:
  brief: Calculates and returns a swimming path between two points in the game world
    for AI navigation.
  description: The FindSwimmingPath method computes a navigable route for units that
    are capable of swimming, taking into account water boundaries and swimable terrain.
    This function is typically used by the AI system to determine how a unit should
    move through aquatic environments. The method utilizes the underlying pathfinding
    system to ensure that the returned path respects game mechanics such as water
    depth, swimable zones, and any obstacles within the swimming area. It is important
    to note that this method only returns valid paths for units that can actually
    swim in the given environment.
  parameters:
  - name: start
    description: The starting position identifier or coordinate for the swimming path.
      This typically represents a node or point in the navigation mesh.
  - name: goal
    description: The destination position identifier or coordinate for the swimming
      path. This also represents a node or point in the navigation mesh.
  returns: A PathResult object containing the computed swimming path. The result includes
    information about whether the path was successfully found, along with the actual
    waypoints that define the route. If no valid swimming path exists between start
    and goal, the method returns an invalid path result.
  examples:
  - title: Basic Swimming Path Calculation
    code: "PathResult result = pathfindingManager.FindSwimmingPath(startNode, endNode);\n\
      if (result.IsValid()) {\n    // Process valid swimming path\n    for (auto&\
      \ point : result.GetWaypoints()) {\n        printf(\"Waypoint: (%f, %f, %f)\\\
      n\", point.x, point.y, point.z);\n    }\n} else {\n    printf(\"No valid swimming\
      \ path found.\\n\");\n}"
    language: cpp
  - title: Using Swimming Path in AI Movement
    code: "class SwimmingAI {\npublic:\n    void MoveToTarget(Unit* unit, Position\
      \ targetPos) {\n        int startNode = GetNavMeshNode(unit->GetPosition());\n\
      \        int goalNode = GetNavMeshNode(targetPos);\n        PathResult path\
      \ = pathfindingManager.FindSwimmingPath(startNode, goalNode);\n        if (path.IsValid())\
      \ {\n            unit->MoveAlongPath(path);\n        } else {\n            //\
      \ Fallback to alternative movement\n            unit->SetMovementType(MOVEMENT_TYPE_WALK);\n\
      \        }\n    }\n};"
    language: cpp
  notes: This method is part of the TrinityCore's advanced pathfinding system and
    relies on precomputed navigation meshes. The underlying implementation uses a
    variant of the A* algorithm optimized for swimming movement. Performance may be
    impacted by complex water boundaries or large numbers of waypoints in the resulting
    path.
  warnings: Ensure that the start and goal parameters represent valid nodes in the
    navigation mesh; otherwise, the method will return an invalid path result. This
    function should not be called on units that cannot swim, as it may produce incorrect
    results or fail to find a path even when one exists.
  related:
  - FindPath
  - FindWalkingPath
  - FindFlyingPath
  - GetNavMeshNode
metadata:
  confidence: 0.85
  generated_at: '2025-11-02T01:54:58.081770'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

api:
  class: MechanicAwareness
  method: AnalyzeSpellMechanic
  signature: MechanicInfo MechanicAwareness::AnalyzeSpellMechanic(uint32 spellId,
    Unit * caster, Unit * target)
documentation:
  brief: Analyzes and retrieves mechanic information for a specified spell cast by
    a caster on a target.
  description: The AnalyzeSpellMechanic method examines a given spell to determine
    its associated mechanic type, which is crucial for understanding how the spell
    interacts with various game mechanics such as immunity, resistance, or special
    effects. This function is typically used in spell processing and combat logic
    to apply appropriate mechanics-based handling. It requires valid Unit pointers
    for both caster and target, and returns a MechanicInfo structure containing detailed
    information about the spell's mechanic properties. The method does not modify
    any state but provides read-only access to spell mechanic data.
  parameters:
  - name: spellId
    description: The unique identifier of the spell to analyze. Must correspond to
      a valid spell entry in the game database.
  - name: caster
    description: Pointer to the Unit object that is casting the spell. Must be a valid
      Unit instance, typically a player or creature.
  - name: target
    description: Pointer to the Unit object that is being targeted by the spell. Must
      be a valid Unit instance.
  returns: Returns a MechanicInfo structure containing detailed information about
    the spell's mechanic properties, including the mechanic type, flags, and other
    relevant data. If the spell ID is invalid or no mechanic data is found, the returned
    structure may contain default or empty values.
  examples:
  - title: Basic Usage Example
    code: "MechanicInfo info = awareness.AnalyzeSpellMechanic(12345, player, target);\n\
      if (info.mechanicType != MECHANIC_NONE)\n{\n    // Process spell based on its\
      \ mechanic type\n    switch (info.mechanicType)\n    {\n        case MECHANIC_STUN:\n\
      \            // Handle stun mechanics\n            break;\n        case MECHANIC_ROOT:\n\
      \            // Handle root mechanics\n            break;\n    }\n}"
    language: cpp
  - title: Advanced Usage with Conditional Logic
    code: "uint32 spellId = 98765;\nUnit* caster = player;\nUnit* target = enemy;\n\
      MechanicInfo info = awareness.AnalyzeSpellMechanic(spellId, caster, target);\n\
      \nif (info.mechanicType != MECHANIC_NONE && info.flags & MECHANIC_FLAG_DISORIENTED)\n\
      {\n    // Apply special handling for disoriented mechanics\n    target->AddAura(12345,\
      \ target); // Example: apply a debuff\n}"
    language: cpp
  notes: This method relies on internal spell data and mechanic definitions stored
    in the TrinityCore database. Ensure that spell IDs are valid and that both caster
    and target Units are properly initialized before calling this function. The returned
    MechanicInfo structure should not be modified directly as it's intended for read-only
    access.
  warnings: Calling this method with null or invalid Unit pointers may result in undefined
    behavior or crashes. Always validate input parameters before invoking the method.
    Be cautious when using spell IDs that are not present in the game database, as
    they may return unexpected results.
  related:
  - GetSpellMechanic
  - IsSpellAffectedByMechanic
  - ApplyMechanicEffect
metadata:
  confidence: 0.9
  generated_at: '2025-11-06T08:48:42.851648'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core

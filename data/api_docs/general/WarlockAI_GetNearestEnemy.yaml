api:
  class: WarlockAI
  method: GetNearestEnemy
  signature: Unit * WarlockAI::GetNearestEnemy(float range)
documentation:
  brief: Finds and returns the nearest enemy Unit within a specified range.
  description: The GetNearestEnemy method searches for the closest hostile unit (enemy)
    within the given range from the WarlockAI's owner. It is commonly used in AI decision-making
    to determine target priority for spell casting or movement. The method performs
    a spatial search using the current position of the AI-controlled unit and evaluates
    all nearby units to find the one that is both hostile and within the specified
    distance. If no valid enemy is found within range, it returns nullptr.
  parameters: []
  returns: A pointer to the nearest Unit object that is an enemy (hostile) within
    the specified range, or nullptr if no such unit exists.
  examples:
  - title: Basic usage to find nearest enemy
    code: "Unit* target = warlockAI->GetNearestEnemy(30.0f);\nif (target && target->IsAlive())\
      \ {\n    // Cast a spell on the nearest enemy\n    warlockAI->DoCast(target,\
      \ SPELL_SHADOW_BOLT);\n}"
    language: cpp
  - title: Using with conditional logic for targeting
    code: "Unit* nearestEnemy = warlockAI->GetNearestEnemy(25.0f);\nif (nearestEnemy\
      \ && nearestEnemy->IsAlive() && !nearestEnemy->HasAura(SPELL_IMMOLATE)) {\n\
      \    // Cast Immolate if not already applied\n    warlockAI->DoCast(nearestEnemy,\
      \ SPELL_IMMOLATE);\n} else if (nearestEnemy) {\n    // Otherwise cast Shadow\
      \ Bolt\n    warlockAI->DoCast(nearestEnemy, SPELL_SHADOW_BOLT);\n}"
    language: cpp
  notes: This method relies on the AI's internal unit positioning and may not account
    for line-of-sight or complex terrain. It is optimized for performance by using
    spatial partitioning techniques where available. The range parameter defines a
    spherical radius from the AI's current position.
  warnings: Ensure that the returned Unit pointer is checked for null before dereferencing
    to avoid segmentation faults. Be cautious when using this method in high-frequency
    loops as it may impact performance if called too often without caching results.
  related:
  - GetNearestEnemy
  - GetNextTarget
  - GetVictim
metadata:
  confidence: 0.95
  generated_at: '2025-11-07T08:53:36.939517'
  generator: lmstudio-qwen3-coder-30b
  version: 1.0.0
  source: core
